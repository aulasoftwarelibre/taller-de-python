{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Inicio \u00b6 Este taller forma parte de las actividades del Aula de Software Libre de la Universidad de C\u00f3rdoba . El contenido del mismo es en parte de producci\u00f3n propia, en parte de otros manuales libres que pueden encontrarse en la secci\u00f3n de Referencias . Contenido \u00b6 Introducci\u00f3n Python B\u00e1sico Python Avanzado M\u00f3dulos Testing Ciencia de Datos con Python Referencias Agradecimientos \u00b6 Este curso ha sido impartido por las siguientes personas: Adri\u00e1n L\u00f3pez \u00c1lvaro Prieto Javier Barbero Marcos Rivera Licencia \u00b6 El material est\u00e1 publicado con licencia Atribuci\u00f3n-NoComercial 4.0 Internacional (CC BY-NC 4.0)","title":"Inicio"},{"location":"#inicio","text":"Este taller forma parte de las actividades del Aula de Software Libre de la Universidad de C\u00f3rdoba . El contenido del mismo es en parte de producci\u00f3n propia, en parte de otros manuales libres que pueden encontrarse en la secci\u00f3n de Referencias .","title":"Inicio"},{"location":"#contenido","text":"Introducci\u00f3n Python B\u00e1sico Python Avanzado M\u00f3dulos Testing Ciencia de Datos con Python Referencias","title":"Contenido"},{"location":"#agradecimientos","text":"Este curso ha sido impartido por las siguientes personas: Adri\u00e1n L\u00f3pez \u00c1lvaro Prieto Javier Barbero Marcos Rivera","title":"Agradecimientos"},{"location":"#licencia","text":"El material est\u00e1 publicado con licencia Atribuci\u00f3n-NoComercial 4.0 Internacional (CC BY-NC 4.0)","title":"Licencia"},{"location":"ia/","text":"Ciencia de Datos con Python \u00b6 La ciencia de datos es un campo interdisciplinario que involucra m\u00e9todos cient\u00edficos, procesos y sistemas para extraer conocimiento o un mejor entendimiento de datos en sus diferentes formas, ya sea estructurados o no estructurados,\u200b lo cual es una continuaci\u00f3n de algunos campos de an\u00e1lisis de datos como la estad\u00edstica, la miner\u00eda de datos, el aprendizaje autom\u00e1tico, y la anal\u00edtica predictiva. Tambi\u00e9n se define La ciencia de datos como \"un concepto para unificar estad\u00edsticas, an\u00e1lisis de datos, aprendizaje autom\u00e1tico, y sus m\u00e9todos relacionados, a efectos de comprender y analizar los fen\u00f3menos reales\", empleando t\u00e9cnicas y teor\u00edas extra\u00eddas de muchos campos dentro del contexto de las matem\u00e1ticas, la estad\u00edstica, la ciencia de la informaci\u00f3n, y la inform\u00e1tica. \u00bfPorque Python? \u00b6 Como ya sabemos, el Data Science se encarga de analizar, transformar datos y extraer informaci\u00f3n de utilidad para la toma de decisiones. Gracias a Python estas tareas se pueden llevar a cabo sin la necesidad de tener conocimientos avanzados de programaci\u00f3n, con pocas l\u00edneas de c\u00f3digo y en entornos de programaci\u00f3n amigables que facilitan la programaci\u00f3n y visualizaci\u00f3n de resultados. En el desarrollo de un proyecto de Data Science existen diferentes bloques para completar dicho proyecto, algunos de los bloques m\u00e1s relevantes son: Extracci\u00f3n de datos Procesamiento de los datos Aplicaci\u00f3n de algoritmos, los cuales pueden ser de machine learning, deep learning o NLP (Natural Language Processing) Terminando con la evaluaci\u00f3n de los resultados Lo que nos lleva a preguntarnos: \u00bfQu\u00e9 herramientas computacionales se pueden utilizar para desarrollar cada uno de los bloques? , la respuesta siempre ser\u00e1 Python, porque cuenta con una gran cantidad de bibliotecas disponibles para cada uno, adem\u00e1s de la gran comunidad de programadores que dan soporte en diferentes foros de programaci\u00f3n. Algunos ejemplos de estas bibliotecas son \u00b6 Nombre Funcionalidad principal Tensorflow Creaci\u00f3n de redes neuronales artificiales Seaborn Visualizaci\u00f3n de datos Pandas Manipulaci\u00f3n de conjuntos de datos NLTK Resolver problemas en el \u00e1rea del Procesamiento del Lenguaje Natural NumPy Computaci\u00f3n de datos en forma de matrices multidimensionales Scikit-learn Procesamiento de datos y algoritmos de machine learning \u00bfComo empezar? \u00b6 Si le interesa este campo, puede consultar la documentaci\u00f3n del siguiente curso realizado por Javier Barbero profesor de la Universidad de C\u00f3rdoba y miembro del grupo de investigaci\u00f3n AYRNA para el Aula de Software Libre : Introducci\u00f3n a la Ciencia de Datos con Python","title":"Ciencia de Datos con Python"},{"location":"ia/#ciencia-de-datos-con-python","text":"La ciencia de datos es un campo interdisciplinario que involucra m\u00e9todos cient\u00edficos, procesos y sistemas para extraer conocimiento o un mejor entendimiento de datos en sus diferentes formas, ya sea estructurados o no estructurados,\u200b lo cual es una continuaci\u00f3n de algunos campos de an\u00e1lisis de datos como la estad\u00edstica, la miner\u00eda de datos, el aprendizaje autom\u00e1tico, y la anal\u00edtica predictiva. Tambi\u00e9n se define La ciencia de datos como \"un concepto para unificar estad\u00edsticas, an\u00e1lisis de datos, aprendizaje autom\u00e1tico, y sus m\u00e9todos relacionados, a efectos de comprender y analizar los fen\u00f3menos reales\", empleando t\u00e9cnicas y teor\u00edas extra\u00eddas de muchos campos dentro del contexto de las matem\u00e1ticas, la estad\u00edstica, la ciencia de la informaci\u00f3n, y la inform\u00e1tica.","title":"Ciencia de Datos con Python"},{"location":"ia/#porque-python","text":"Como ya sabemos, el Data Science se encarga de analizar, transformar datos y extraer informaci\u00f3n de utilidad para la toma de decisiones. Gracias a Python estas tareas se pueden llevar a cabo sin la necesidad de tener conocimientos avanzados de programaci\u00f3n, con pocas l\u00edneas de c\u00f3digo y en entornos de programaci\u00f3n amigables que facilitan la programaci\u00f3n y visualizaci\u00f3n de resultados. En el desarrollo de un proyecto de Data Science existen diferentes bloques para completar dicho proyecto, algunos de los bloques m\u00e1s relevantes son: Extracci\u00f3n de datos Procesamiento de los datos Aplicaci\u00f3n de algoritmos, los cuales pueden ser de machine learning, deep learning o NLP (Natural Language Processing) Terminando con la evaluaci\u00f3n de los resultados Lo que nos lleva a preguntarnos: \u00bfQu\u00e9 herramientas computacionales se pueden utilizar para desarrollar cada uno de los bloques? , la respuesta siempre ser\u00e1 Python, porque cuenta con una gran cantidad de bibliotecas disponibles para cada uno, adem\u00e1s de la gran comunidad de programadores que dan soporte en diferentes foros de programaci\u00f3n.","title":"\u00bfPorque Python?"},{"location":"ia/#algunos-ejemplos-de-estas-bibliotecas-son","text":"Nombre Funcionalidad principal Tensorflow Creaci\u00f3n de redes neuronales artificiales Seaborn Visualizaci\u00f3n de datos Pandas Manipulaci\u00f3n de conjuntos de datos NLTK Resolver problemas en el \u00e1rea del Procesamiento del Lenguaje Natural NumPy Computaci\u00f3n de datos en forma de matrices multidimensionales Scikit-learn Procesamiento de datos y algoritmos de machine learning","title":"Algunos ejemplos de estas bibliotecas son"},{"location":"ia/#como-empezar","text":"Si le interesa este campo, puede consultar la documentaci\u00f3n del siguiente curso realizado por Javier Barbero profesor de la Universidad de C\u00f3rdoba y miembro del grupo de investigaci\u00f3n AYRNA para el Aula de Software Libre : Introducci\u00f3n a la Ciencia de Datos con Python","title":"\u00bfComo empezar?"},{"location":"referencias/","text":"Referencias \u00b6 Documentaci\u00f3n oficial en ingl\u00e9s .","title":"Referencias"},{"location":"referencias/#referencias","text":"Documentaci\u00f3n oficial en ingl\u00e9s .","title":"Referencias"},{"location":"Introducci%C3%B3n/ide/","text":"Entorno de Trabajo \u00b6 Nosotros en este taller trabajaremos con Visual Studio Code ya que cuenta con una gran variedad de extensiones que nos ser\u00e1n de utilidad a la hora de desarrollar. Ademas cuenta con una terminal integrada en la que podremos ejecutar facilmente los programas que vayamos realizando. Tambi\u00e9n crearemos una carpeta en la que iremos guardando los programas que hemos realizado. Esta carpeta deberemos abrirla en Visual para que el flujo de trabajo sea lo mas fluido posible. Pasos \u00b6 1. Instalar VSCode \u00b6 Simplemente clicamos en el siguiente enlace y descargamos la versi\u00f3n para nuestro sistema operativo: https://code.visualstudio.com/download 2. Crear la carpeta \u00b6 mkdir taller-de-python 3. Abrir la carpeta en VSCode \u00b6 Abrimos la carpeta Creamos un nuevo fichero que se llame holamundo.py Ahora se nos abrir\u00e1 el archivo que acabamos de crear. Aqu\u00ed ya podemos comenzar a hacer nuestros programas y como no pod\u00eda ser de otra forma el primer programa que haremos ser\u00e1 imprimir un hello world para ello copiaremos el siguiente c\u00f3digo y lo pegaremos en el archivo acto seguido pulsaremos el bot\u00f3n verde de play que se encuentra arriba a la derecha para ejecutarlo. print(\"Hello World\") Si has seguido los pasos al pie de la letra te habr\u00e1s dado cuenta que al ejecutarlo sale un error de indentaci\u00f3n. Esto se debe a que a diferencia de otros lenguajes como C++, Python es sensible a las indentaciones ya que estas reemplazan a los par\u00e9ntesis. Para que el programa anterior funcione simplemente debemos eliminar las indentaciones sobrantes y volver a pulsar Play . Hecho esto deber\u00edamos de haber obtenido un resultado similar al que obtuvimos en el apartado anterior con el int\u00e9rprete Una vez hemos hecho nuestro primer programa llega la hora de profundizar un poco m\u00e1s en este lenguaje. Para ayudar a relacionar conceptos y entenderlo todo un poco mejor todos los ejemplos de c\u00f3digo del curso estar\u00e1n acompa\u00f1ados de una implementaci\u00f3n similar en C++ que puede ser compilada y ejecutada para comprobar los resultados y ver las similitudes y diferencias entre ambos lenguajes.","title":"Entorno de Trabajo"},{"location":"Introducci%C3%B3n/ide/#entorno-de-trabajo","text":"Nosotros en este taller trabajaremos con Visual Studio Code ya que cuenta con una gran variedad de extensiones que nos ser\u00e1n de utilidad a la hora de desarrollar. Ademas cuenta con una terminal integrada en la que podremos ejecutar facilmente los programas que vayamos realizando. Tambi\u00e9n crearemos una carpeta en la que iremos guardando los programas que hemos realizado. Esta carpeta deberemos abrirla en Visual para que el flujo de trabajo sea lo mas fluido posible.","title":"Entorno de Trabajo"},{"location":"Introducci%C3%B3n/ide/#pasos","text":"","title":"Pasos"},{"location":"Introducci%C3%B3n/ide/#1-instalar-vscode","text":"Simplemente clicamos en el siguiente enlace y descargamos la versi\u00f3n para nuestro sistema operativo: https://code.visualstudio.com/download","title":"1. Instalar VSCode"},{"location":"Introducci%C3%B3n/ide/#2-crear-la-carpeta","text":"mkdir taller-de-python","title":"2. Crear la carpeta"},{"location":"Introducci%C3%B3n/ide/#3-abrir-la-carpeta-en-vscode","text":"Abrimos la carpeta Creamos un nuevo fichero que se llame holamundo.py Ahora se nos abrir\u00e1 el archivo que acabamos de crear. Aqu\u00ed ya podemos comenzar a hacer nuestros programas y como no pod\u00eda ser de otra forma el primer programa que haremos ser\u00e1 imprimir un hello world para ello copiaremos el siguiente c\u00f3digo y lo pegaremos en el archivo acto seguido pulsaremos el bot\u00f3n verde de play que se encuentra arriba a la derecha para ejecutarlo. print(\"Hello World\") Si has seguido los pasos al pie de la letra te habr\u00e1s dado cuenta que al ejecutarlo sale un error de indentaci\u00f3n. Esto se debe a que a diferencia de otros lenguajes como C++, Python es sensible a las indentaciones ya que estas reemplazan a los par\u00e9ntesis. Para que el programa anterior funcione simplemente debemos eliminar las indentaciones sobrantes y volver a pulsar Play . Hecho esto deber\u00edamos de haber obtenido un resultado similar al que obtuvimos en el apartado anterior con el int\u00e9rprete Una vez hemos hecho nuestro primer programa llega la hora de profundizar un poco m\u00e1s en este lenguaje. Para ayudar a relacionar conceptos y entenderlo todo un poco mejor todos los ejemplos de c\u00f3digo del curso estar\u00e1n acompa\u00f1ados de una implementaci\u00f3n similar en C++ que puede ser compilada y ejecutada para comprobar los resultados y ver las similitudes y diferencias entre ambos lenguajes.","title":"3. Abrir la carpeta en VSCode"},{"location":"Introducci%C3%B3n/instalacion/","text":"Instalaci\u00f3n \u00b6 Ubuntu 20.04 y otras versiones de Debian Linux se entregan con Python 3 preinstalado. Para asegurarnos de que nuestras versiones est\u00e9n actualizadas, ejecutaremos los siguientes comandos: sudo apt update && apt upgrade Una vez completado el proceso, podemos comprobar la versi\u00f3n de Python 3 instalada en el sistema escribiendo lo siguiente: python3 -V Para instalar Python en otros sistemas operativos tales como Windows o MacOS, descargar el instalador correspondiente de la web de Python: https://www.python.org/downloads/ Para gestionar los paquetes de software para Python, instalaremos pip, una herramienta que instalar\u00e1 y gestionar\u00e1 los paquetes de programaci\u00f3n que queramos utilizar en nuestros proyectos de desarrollo: sudo apt install -y python3-pip Hay m\u00e1s paquetes y herramientas de desarrollo que debemos instalar para asegurarnos de contar con una configuraci\u00f3n s\u00f3lida para nuestro entorno de programaci\u00f3n: sudo apt install -y build-essential libssl-dev libffi-dev python3-dev Virtualenv se usa para administrar paquetes de Python de diferentes proyectos. El uso de virtualenv permite evitar instalar paquetes de Python a nivel global, lo que podr\u00eda da\u00f1ar las herramientas del sistema u otros proyectos. Podemos instalar virtualenv usando pip: pip3 install --user virtualenv Para m\u00e1s informaci\u00f3n sobre los usos de esta herramienta visite la siguiente web: https://virtualenv.pypa.io/en/latest/index.html","title":"Instalaci\u00f3n"},{"location":"Introducci%C3%B3n/instalacion/#instalacion","text":"Ubuntu 20.04 y otras versiones de Debian Linux se entregan con Python 3 preinstalado. Para asegurarnos de que nuestras versiones est\u00e9n actualizadas, ejecutaremos los siguientes comandos: sudo apt update && apt upgrade Una vez completado el proceso, podemos comprobar la versi\u00f3n de Python 3 instalada en el sistema escribiendo lo siguiente: python3 -V Para instalar Python en otros sistemas operativos tales como Windows o MacOS, descargar el instalador correspondiente de la web de Python: https://www.python.org/downloads/ Para gestionar los paquetes de software para Python, instalaremos pip, una herramienta que instalar\u00e1 y gestionar\u00e1 los paquetes de programaci\u00f3n que queramos utilizar en nuestros proyectos de desarrollo: sudo apt install -y python3-pip Hay m\u00e1s paquetes y herramientas de desarrollo que debemos instalar para asegurarnos de contar con una configuraci\u00f3n s\u00f3lida para nuestro entorno de programaci\u00f3n: sudo apt install -y build-essential libssl-dev libffi-dev python3-dev Virtualenv se usa para administrar paquetes de Python de diferentes proyectos. El uso de virtualenv permite evitar instalar paquetes de Python a nivel global, lo que podr\u00eda da\u00f1ar las herramientas del sistema u otros proyectos. Podemos instalar virtualenv usando pip: pip3 install --user virtualenv Para m\u00e1s informaci\u00f3n sobre los usos de esta herramienta visite la siguiente web: https://virtualenv.pypa.io/en/latest/index.html","title":"Instalaci\u00f3n"},{"location":"Introducci%C3%B3n/interprete/","text":"Int\u00e9rprete de Python \u00b6 Al instalar Python se nos instalar\u00e1 tambi\u00e9n su interprete con el que podremos crear ejecutar programas de Python para acceder a el en linux simplemente debemos abrir una terminal y ejecutar el siguiente comando: python3 Una vez abierto en nuestra consola aparecer\u00e1 lo siguiente: Python 3.8.5 (default, Jul 28 2020, 12:59:40) [GCC 9.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> Ahora podemos crear y ejecutar programas empecemos por el cl\u00e1sico Hola Mundo escribiendo la siguiente linea y pulsando enter: print(\"Hello World\") Tras esto en nuestra consola aparecer\u00e1 lo siguiente: Python 3.8.5 (default, Jul 28 2020, 12:59:40) [GCC 9.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> print(\"Hello World\") Hello World >>> Para cerrar el interprete escribiremos el siguiente comando y pulsaremos enter: exit() Tambi\u00e9n podemos ejecutar ficheros .py para ello abriremos una terminal y nos iremos al directorio en el que se encuentre el archivo una vez all\u00ed escribiremos lo siguiente: python3 file.py Siendo file.py el nombre del fichero que queramos ejecutar. Puedes hacer la prueba descargando y ejecutando el siguiente archivo: holamundo.py","title":"Int\u00e9rprete de Python"},{"location":"Introducci%C3%B3n/interprete/#interprete-de-python","text":"Al instalar Python se nos instalar\u00e1 tambi\u00e9n su interprete con el que podremos crear ejecutar programas de Python para acceder a el en linux simplemente debemos abrir una terminal y ejecutar el siguiente comando: python3 Una vez abierto en nuestra consola aparecer\u00e1 lo siguiente: Python 3.8.5 (default, Jul 28 2020, 12:59:40) [GCC 9.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> Ahora podemos crear y ejecutar programas empecemos por el cl\u00e1sico Hola Mundo escribiendo la siguiente linea y pulsando enter: print(\"Hello World\") Tras esto en nuestra consola aparecer\u00e1 lo siguiente: Python 3.8.5 (default, Jul 28 2020, 12:59:40) [GCC 9.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> print(\"Hello World\") Hello World >>> Para cerrar el interprete escribiremos el siguiente comando y pulsaremos enter: exit() Tambi\u00e9n podemos ejecutar ficheros .py para ello abriremos una terminal y nos iremos al directorio en el que se encuentre el archivo una vez all\u00ed escribiremos lo siguiente: python3 file.py Siendo file.py el nombre del fichero que queramos ejecutar. Puedes hacer la prueba descargando y ejecutando el siguiente archivo: holamundo.py","title":"Int\u00e9rprete de Python"},{"location":"Introducci%C3%B3n/que-es/","text":"\u00bfQu\u00e9 es Python? \u00b6 Introducci\u00f3n \u00b6 Python es un lenguaje de programaci\u00f3n interpretado cuya filosof\u00eda hace hincapi\u00e9 en la legibilidad de su c\u00f3digo. Se trata de un lenguaje de programaci\u00f3n multiparadigma, ya que soporta orientaci\u00f3n a objetos, programaci\u00f3n imperativa y, en menor medida, programaci\u00f3n funcional. Es un lenguaje interpretado, din\u00e1mico y multiplataforma. Es administrado por la Python Software Foundation. Posee una licencia de c\u00f3digo abierto, denominada Python Software Foundation License. La extensi\u00f3n de sus ficheros suele ser .py Ha pasado por numerosas versiones, y actualmente su \u00faltima versi\u00f3n estable es la 3.9.0","title":"\u00bfQu\u00e9 es Python?"},{"location":"Introducci%C3%B3n/que-es/#que-es-python","text":"","title":"\u00bfQu\u00e9 es Python?"},{"location":"Introducci%C3%B3n/que-es/#introduccion","text":"Python es un lenguaje de programaci\u00f3n interpretado cuya filosof\u00eda hace hincapi\u00e9 en la legibilidad de su c\u00f3digo. Se trata de un lenguaje de programaci\u00f3n multiparadigma, ya que soporta orientaci\u00f3n a objetos, programaci\u00f3n imperativa y, en menor medida, programaci\u00f3n funcional. Es un lenguaje interpretado, din\u00e1mico y multiplataforma. Es administrado por la Python Software Foundation. Posee una licencia de c\u00f3digo abierto, denominada Python Software Foundation License. La extensi\u00f3n de sus ficheros suele ser .py Ha pasado por numerosas versiones, y actualmente su \u00faltima versi\u00f3n estable es la 3.9.0","title":"Introducci\u00f3n"},{"location":"Introducci%C3%B3n/usos/","text":"\u00bfPara que se utiliza Python? \u00b6 Entre los m\u00faltiples usos que se le puede dar a este lenguaje de programaci\u00f3n destacan los siguientes: Machine Learning e IA \u00b6 Conjunto de herramientas para el an\u00e1lisis y procesado de datos con Python Desarrollo de juegos \u00b6 Conjunto de m\u00f3dulos que permite la creaci\u00f3n de videojuegos en 2D de forma sencilla. Tambien puede utilizarse para crar otros programas multimedia o interfaces gr\u00e1ficas de usuario Aplicaciones de escritorio \u00b6 Tkinter es un binding de la biblioteca gr\u00e1fica Tcl/Tk para Python. Se considera un est\u00e1ndar para la creaci\u00f3n de interfaces gr\u00e1ficas de usuario en Python Desarrollo web \u00b6 Django es un framework de desarrollo web de c\u00f3digo abierto, escrito en Python y que respeta el patr\u00f3n de dise\u00f1o conocido como modelo vista controlador","title":"\u00bfPara que se utiliza Python?"},{"location":"Introducci%C3%B3n/usos/#para-que-se-utiliza-python","text":"Entre los m\u00faltiples usos que se le puede dar a este lenguaje de programaci\u00f3n destacan los siguientes:","title":"\u00bfPara que se utiliza Python?"},{"location":"Introducci%C3%B3n/usos/#machine-learning-e-ia","text":"Conjunto de herramientas para el an\u00e1lisis y procesado de datos con Python","title":"Machine Learning e IA"},{"location":"Introducci%C3%B3n/usos/#desarrollo-de-juegos","text":"Conjunto de m\u00f3dulos que permite la creaci\u00f3n de videojuegos en 2D de forma sencilla. Tambien puede utilizarse para crar otros programas multimedia o interfaces gr\u00e1ficas de usuario","title":"Desarrollo de juegos"},{"location":"Introducci%C3%B3n/usos/#aplicaciones-de-escritorio","text":"Tkinter es un binding de la biblioteca gr\u00e1fica Tcl/Tk para Python. Se considera un est\u00e1ndar para la creaci\u00f3n de interfaces gr\u00e1ficas de usuario en Python","title":"Aplicaciones de escritorio"},{"location":"Introducci%C3%B3n/usos/#desarrollo-web","text":"Django es un framework de desarrollo web de c\u00f3digo abierto, escrito en Python y que respeta el patr\u00f3n de dise\u00f1o conocido como modelo vista controlador","title":"Desarrollo web"},{"location":"M%C3%B3dulos/00-intro/","text":"Introducci\u00f3n \u00b6 Python es un lenguaje que viene con \"pilas incluidas\": la librer\u00eda est\u00e1ndar del int\u00e9rprete incluye de serie multitud de m\u00f3dulos . A continuaci\u00f3n se comentan algunos de estos m\u00f3dulos que te ayudar\u00e1n a realizar operaciones complejas de manera inmediata.","title":"Introducci\u00f3n"},{"location":"M%C3%B3dulos/00-intro/#introduccion","text":"Python es un lenguaje que viene con \"pilas incluidas\": la librer\u00eda est\u00e1ndar del int\u00e9rprete incluye de serie multitud de m\u00f3dulos . A continuaci\u00f3n se comentan algunos de estos m\u00f3dulos que te ayudar\u00e1n a realizar operaciones complejas de manera inmediata.","title":"Introducci\u00f3n"},{"location":"M%C3%B3dulos/01-carga/","text":"Carga de m\u00f3dulos \u00b6 Cuando trabajamos desde el int\u00e9rprete, una vez lo cerramos perdemos todo el trabajo que hemos creado. Por tanto, si queremos que nuestro programa perdure, escribiremos el c\u00f3digo en un fichero de texto, esto es, un script . Python es un lenguaje interpretado , luego no es necesario un proceso de compilaci\u00f3n como en otros lenguajes como C sino que podemos ejecutar un script directamente. Por ejemplo, si guardamos nuestro programa un fichero programa.py , podemos lanzarlo con el comando: python programa.py Sin embargo, en cuanto nuestro programa crezca un poco, necesitaremos partirlo en distintos ficheros para una mejor organizaci\u00f3n. Python nos ofrece un mecanismo para guardar definiciones en un fichero para usarlos en un script o directamente en el int\u00e9rprete: los m\u00f3dulos . Por ejemplo, podemos definir el siguiente fichero modulo.py : # modulo.py def mutiplicar ( a , b ): return a * b def sumar ( a , b ): return a + b def restar ( a , b ): return a - b As\u00ed, en nuestro programa.py podemos importar el m\u00f3dulo con la sintaxis import < modulo > . Al igual que como pasa en otros lenguajes (por ejemplo, cuando usamos el #include \"modulo.h\" de C), el int\u00e9rprete de Python busca primero en el directorio actual y despu\u00e9s en las librer\u00edas instaladas: # programa.py # Por defecto, busca un fichero \"modulo.py\" en el # mismo directorio en el que estamos import modulo producto = modulo . multiplicar ( 2 , 3 ) print ( producto ) # >>> 6 suma = modulo . sumar ( 2 , 3 ) print ( suma ) # >>> 5 Podemos asignar un alias al m\u00f3dulo que acabamos de importar con import < modulo > as < alias > : import modulo as mod producto = mod . multiplicar ( 2 , 3 ) print ( producto ) # >>> 6 suma = mod . sumar ( 2 , 3 ) print ( suma ) # >>> 5 Tambi\u00e9n podemos importar s\u00f3lo algunos elementos particulares con from < modulo > import < elemento > : from modulo import sumar from modulo import restar as rest # Tambi\u00e9n podemos usar alias! resta = rest ( 2 , 3 ) print ( resta ) # >>> -1 suma = sumar ( 2 , 3 ) print ( suma ) # >>> 5 Cuidado Existe otra sintaxis con la que podemos importar todos los elementos de un m\u00f3dulo al contexto global: from modulo import * suma = sumar ( 2 , 3 ) resta = restar ( 2 , 3 ) producto = multiplicar ( 2 , 3 ) Esto puede parecer c\u00f3modo, pero potencialmente puede causarnos problemas , ya que podr\u00edamos \"contaminar\" el espacio global con nombres inesperados que sobreescriben alg\u00fan otro que estemos usando. Evita usar esta sintaxis . En las secciones a continuaci\u00f3n vamos a trabajar con m\u00f3dulos de la librer\u00eda est\u00e1ndar, as\u00ed que no es necesario que instalemos nada.","title":"Carga de m\u00f3dulos"},{"location":"M%C3%B3dulos/01-carga/#carga-de-modulos","text":"Cuando trabajamos desde el int\u00e9rprete, una vez lo cerramos perdemos todo el trabajo que hemos creado. Por tanto, si queremos que nuestro programa perdure, escribiremos el c\u00f3digo en un fichero de texto, esto es, un script . Python es un lenguaje interpretado , luego no es necesario un proceso de compilaci\u00f3n como en otros lenguajes como C sino que podemos ejecutar un script directamente. Por ejemplo, si guardamos nuestro programa un fichero programa.py , podemos lanzarlo con el comando: python programa.py Sin embargo, en cuanto nuestro programa crezca un poco, necesitaremos partirlo en distintos ficheros para una mejor organizaci\u00f3n. Python nos ofrece un mecanismo para guardar definiciones en un fichero para usarlos en un script o directamente en el int\u00e9rprete: los m\u00f3dulos . Por ejemplo, podemos definir el siguiente fichero modulo.py : # modulo.py def mutiplicar ( a , b ): return a * b def sumar ( a , b ): return a + b def restar ( a , b ): return a - b As\u00ed, en nuestro programa.py podemos importar el m\u00f3dulo con la sintaxis import < modulo > . Al igual que como pasa en otros lenguajes (por ejemplo, cuando usamos el #include \"modulo.h\" de C), el int\u00e9rprete de Python busca primero en el directorio actual y despu\u00e9s en las librer\u00edas instaladas: # programa.py # Por defecto, busca un fichero \"modulo.py\" en el # mismo directorio en el que estamos import modulo producto = modulo . multiplicar ( 2 , 3 ) print ( producto ) # >>> 6 suma = modulo . sumar ( 2 , 3 ) print ( suma ) # >>> 5 Podemos asignar un alias al m\u00f3dulo que acabamos de importar con import < modulo > as < alias > : import modulo as mod producto = mod . multiplicar ( 2 , 3 ) print ( producto ) # >>> 6 suma = mod . sumar ( 2 , 3 ) print ( suma ) # >>> 5 Tambi\u00e9n podemos importar s\u00f3lo algunos elementos particulares con from < modulo > import < elemento > : from modulo import sumar from modulo import restar as rest # Tambi\u00e9n podemos usar alias! resta = rest ( 2 , 3 ) print ( resta ) # >>> -1 suma = sumar ( 2 , 3 ) print ( suma ) # >>> 5 Cuidado Existe otra sintaxis con la que podemos importar todos los elementos de un m\u00f3dulo al contexto global: from modulo import * suma = sumar ( 2 , 3 ) resta = restar ( 2 , 3 ) producto = multiplicar ( 2 , 3 ) Esto puede parecer c\u00f3modo, pero potencialmente puede causarnos problemas , ya que podr\u00edamos \"contaminar\" el espacio global con nombres inesperados que sobreescriben alg\u00fan otro que estemos usando. Evita usar esta sintaxis . En las secciones a continuaci\u00f3n vamos a trabajar con m\u00f3dulos de la librer\u00eda est\u00e1ndar, as\u00ed que no es necesario que instalemos nada.","title":"Carga de m\u00f3dulos"},{"location":"M%C3%B3dulos/02-math/","text":"Operaciones matem\u00e1ticas: math \u00b6 Documentaci\u00f3n Las operaciones matem\u00e1ticas es una de las funcionalidades m\u00e1s b\u00e1sicas de cualquier lenguaje de programaci\u00f3n. En Python las puedes encontrar en el m\u00f3dulo math . import math Aqu\u00ed est\u00e1n definidas algunas de las constantes fundamentales: math . pi # >> 3.141592653589793 math . e # >> 2.718281828459045 Tambi\u00e9n tenemos acceso a funciones de uso com\u00fan, como ra\u00edces y logaritmos: math . sqrt ( 2 ) # Ra\u00edz cuadrada # >> 1.4142135623730951 math . log ( 5 ) # Logaritmo natural (base e) # >> 1.6094379124341003 Python tambi\u00e9n nos permite trabajar con \u00e1ngulos f\u00e1cilmente: math . sin ( math . pi / 2 ) # Funci\u00f3n seno # >> 1.0 math . cosh ( 2 ) # Funci\u00f3n coseno hiperb\u00f3lico # >> 3.7621956910836314 math . radians ( 30 ) # Pasar de grados a radianes # >> 0.5235987755982988 (~ pi/6) Por \u00faltimo, algunas funciones miscel\u00e1neas que podr\u00edan ser de utilidad: math . gcd ( 12 , 34 ) # M\u00e1ximo com\u00fan divisor # >> 2 math . prod ([ 3 , 5 , 7 ]) # Productorio # >> 105 (3 * 5 * 7) math . factorial ( 7 ) # Factorial # >> 5040 Por \u00faltimo mencionar que, de base, tambi\u00e9n podemos trabajar con datos num\u00e9ricos muy potentes: # Enteros de tama\u00f1o arbitrario por defecto!: 12381247283945723895734818913812 * 6788678456749293283420582137 # >> 84052306704208035914529211542310875743692802848875069776244 # N\u00fameros complejos (usamos j en lugar de i): ( 3 + 4 j ) * ( 7 + 10 j ) # >> (-19+58j) # Fracciones from fractions import Fraction Fraction ( 10 , 9 ) / Fraction ( 7 , 8 ) # >> Fraction(143, 72)","title":"Operaciones matem\u00e1ticas: `math`"},{"location":"M%C3%B3dulos/02-math/#operaciones-matematicas-math","text":"Documentaci\u00f3n Las operaciones matem\u00e1ticas es una de las funcionalidades m\u00e1s b\u00e1sicas de cualquier lenguaje de programaci\u00f3n. En Python las puedes encontrar en el m\u00f3dulo math . import math Aqu\u00ed est\u00e1n definidas algunas de las constantes fundamentales: math . pi # >> 3.141592653589793 math . e # >> 2.718281828459045 Tambi\u00e9n tenemos acceso a funciones de uso com\u00fan, como ra\u00edces y logaritmos: math . sqrt ( 2 ) # Ra\u00edz cuadrada # >> 1.4142135623730951 math . log ( 5 ) # Logaritmo natural (base e) # >> 1.6094379124341003 Python tambi\u00e9n nos permite trabajar con \u00e1ngulos f\u00e1cilmente: math . sin ( math . pi / 2 ) # Funci\u00f3n seno # >> 1.0 math . cosh ( 2 ) # Funci\u00f3n coseno hiperb\u00f3lico # >> 3.7621956910836314 math . radians ( 30 ) # Pasar de grados a radianes # >> 0.5235987755982988 (~ pi/6) Por \u00faltimo, algunas funciones miscel\u00e1neas que podr\u00edan ser de utilidad: math . gcd ( 12 , 34 ) # M\u00e1ximo com\u00fan divisor # >> 2 math . prod ([ 3 , 5 , 7 ]) # Productorio # >> 105 (3 * 5 * 7) math . factorial ( 7 ) # Factorial # >> 5040 Por \u00faltimo mencionar que, de base, tambi\u00e9n podemos trabajar con datos num\u00e9ricos muy potentes: # Enteros de tama\u00f1o arbitrario por defecto!: 12381247283945723895734818913812 * 6788678456749293283420582137 # >> 84052306704208035914529211542310875743692802848875069776244 # N\u00fameros complejos (usamos j en lugar de i): ( 3 + 4 j ) * ( 7 + 10 j ) # >> (-19+58j) # Fracciones from fractions import Fraction Fraction ( 10 , 9 ) / Fraction ( 7 , 8 ) # >> Fraction(143, 72)","title":"Operaciones matem\u00e1ticas: math"},{"location":"M%C3%B3dulos/03-str/","text":"Operaciones sobre cadenas: str \u00b6 Uno de los puntos fuertes de Python es la facilidad del manejo de cadenas. Tenemos mucha flexibilidad para definir cadenas y adem\u00e1s disponemos de muchas operaciones sobre ellas: 'escribir En May\u00fasuclas y miN\u00fasculas' . capitalize () # >> 'Escribir en may\u00fasuclas y min\u00fasculas' 'uno, dos, tres' . split ( ', ' ) # >> ['uno', 'dos', 'tres'] '''Esto es una cadena multil\u00ednea. Puedes escribir saltos de l\u00ednea entre medias. Esto es un ejemplo y no se me ocurre qu\u00e9 m\u00e1s poner''' . splitlines () # >> ['Esto es una cadena multil\u00ednea.', 'Puedes escribir saltos de l\u00ednea entre medias.', 'Esto es un ejemplo y no se me ocurre qu\u00e9 m\u00e1s poner'] Si tenemos que construir cadenas a partir de variables en nuestro c\u00f3digo tenemos varias formas de hacerlo. El m\u00e9todo original se parece mucho a c\u00f3mo lo hacemos en C con la funci\u00f3n printf . Para ello, usamos el operador % sobre una cadena. entero = 3 flotante = 2.1 cadena = 'hola' 'Igual que printf en C, puedes imprimir valores: %d ' % entero # >> 'Igual que printf en C, puedes imprimir valores: 3' 'Puedes poner m\u00e1s de un valor: %d y \" %s \"' % ( entero + 2 , cadena ) # >> 'Puedes poner m\u00e1s de un valor: 5 y \"hola\"' 'Y puedes especificar el formato: %.3f ' % flotante # >> 'Y puedes especificar el formato: 2.100' Tambi\u00e9n podemos usar el m\u00e9todo .format() , que nos permite mayor flexibilidad en el orden de los par\u00e1metros y puede hacer el c\u00f3digo m\u00e1s legible. 'Otra forma de formatear es con el m\u00e9todo \"format\": {} ' . format ( entero ) # >> 'Otra forma de formatear es con el m\u00e9todo \"format\": 3' 'Puedes especificar el orden: {2} , {0} , {1} ' . format ( entero , flotante , cadena ) # >> 'Puedes especificar el orden: hola, 3, 2.1' 'O incluso llamarlos por su nombre: {n} , {f} , {c} ' . format ( n = entero + 1 , f = flotante * 2 , c = cadena ) # >> 'O incluso llamarlos por su nombre: 4, 4.2, hola' Por \u00faltimo, desde la versi\u00f3n 3.6, podemos integrar las propias expresiones dentro de la cadena usando lo que se denomina \"f-strings\": f 'A partir de Python 3.6 puedes usar \"f-strings\": { entero + 1 } , { flotante * 2 : .3f } , { cadena } ' # >> 'A partir de Python 3.6 puedes usar \"f-strings\": 4, 4.200, hola' Consejo Ah\u00ed fuera encontrar\u00e1s programas que utilizan cualquier combinaci\u00f3n de los tres m\u00e9todos anteriores (siempre el mismo o mezclados). Nuestro consejo es que, siguiendo los principio de \"c\u00f3digo limpio\", trates de adherirte a un s\u00f3lo m\u00e9todo dentro del mismo repositorio de c\u00f3digo para facilitar la lectura. Si se trata de c\u00f3digo desde cero y se usa una versi\u00f3n compatible, recomendamos usar los f-string por ser generalmente m\u00e1s legibles y c\u00f3modos. Eso s\u00ed, en situaciones concretas podr\u00eda tener m\u00e1s sentido usar uno sobre los dem\u00e1s. \u00a1Piensa bien lo que haces y ponte en el lugar de alguien leyendo tu c\u00f3digo!","title":"Operaciones sobre cadenas: `str`"},{"location":"M%C3%B3dulos/03-str/#operaciones-sobre-cadenas-str","text":"Uno de los puntos fuertes de Python es la facilidad del manejo de cadenas. Tenemos mucha flexibilidad para definir cadenas y adem\u00e1s disponemos de muchas operaciones sobre ellas: 'escribir En May\u00fasuclas y miN\u00fasculas' . capitalize () # >> 'Escribir en may\u00fasuclas y min\u00fasculas' 'uno, dos, tres' . split ( ', ' ) # >> ['uno', 'dos', 'tres'] '''Esto es una cadena multil\u00ednea. Puedes escribir saltos de l\u00ednea entre medias. Esto es un ejemplo y no se me ocurre qu\u00e9 m\u00e1s poner''' . splitlines () # >> ['Esto es una cadena multil\u00ednea.', 'Puedes escribir saltos de l\u00ednea entre medias.', 'Esto es un ejemplo y no se me ocurre qu\u00e9 m\u00e1s poner'] Si tenemos que construir cadenas a partir de variables en nuestro c\u00f3digo tenemos varias formas de hacerlo. El m\u00e9todo original se parece mucho a c\u00f3mo lo hacemos en C con la funci\u00f3n printf . Para ello, usamos el operador % sobre una cadena. entero = 3 flotante = 2.1 cadena = 'hola' 'Igual que printf en C, puedes imprimir valores: %d ' % entero # >> 'Igual que printf en C, puedes imprimir valores: 3' 'Puedes poner m\u00e1s de un valor: %d y \" %s \"' % ( entero + 2 , cadena ) # >> 'Puedes poner m\u00e1s de un valor: 5 y \"hola\"' 'Y puedes especificar el formato: %.3f ' % flotante # >> 'Y puedes especificar el formato: 2.100' Tambi\u00e9n podemos usar el m\u00e9todo .format() , que nos permite mayor flexibilidad en el orden de los par\u00e1metros y puede hacer el c\u00f3digo m\u00e1s legible. 'Otra forma de formatear es con el m\u00e9todo \"format\": {} ' . format ( entero ) # >> 'Otra forma de formatear es con el m\u00e9todo \"format\": 3' 'Puedes especificar el orden: {2} , {0} , {1} ' . format ( entero , flotante , cadena ) # >> 'Puedes especificar el orden: hola, 3, 2.1' 'O incluso llamarlos por su nombre: {n} , {f} , {c} ' . format ( n = entero + 1 , f = flotante * 2 , c = cadena ) # >> 'O incluso llamarlos por su nombre: 4, 4.2, hola' Por \u00faltimo, desde la versi\u00f3n 3.6, podemos integrar las propias expresiones dentro de la cadena usando lo que se denomina \"f-strings\": f 'A partir de Python 3.6 puedes usar \"f-strings\": { entero + 1 } , { flotante * 2 : .3f } , { cadena } ' # >> 'A partir de Python 3.6 puedes usar \"f-strings\": 4, 4.200, hola' Consejo Ah\u00ed fuera encontrar\u00e1s programas que utilizan cualquier combinaci\u00f3n de los tres m\u00e9todos anteriores (siempre el mismo o mezclados). Nuestro consejo es que, siguiendo los principio de \"c\u00f3digo limpio\", trates de adherirte a un s\u00f3lo m\u00e9todo dentro del mismo repositorio de c\u00f3digo para facilitar la lectura. Si se trata de c\u00f3digo desde cero y se usa una versi\u00f3n compatible, recomendamos usar los f-string por ser generalmente m\u00e1s legibles y c\u00f3modos. Eso s\u00ed, en situaciones concretas podr\u00eda tener m\u00e1s sentido usar uno sobre los dem\u00e1s. \u00a1Piensa bien lo que haces y ponte en el lugar de alguien leyendo tu c\u00f3digo!","title":"Operaciones sobre cadenas: str"},{"location":"M%C3%B3dulos/04-itertools/","text":"Iteradores: itertools \u00b6 En Python llamamos iterable a todo aquel objeto que podemos recorrer mediante un bucle for : for elemento in iterable : func ( elemento ) Esto por supuesto incluye listas ( list ), pero tambi\u00e9n tuplas ( tuple ), cadenas ( str ) e incluso elementos que no tienen un orden predeterminado como diccionarios ( dict ) o conjuntos ( set ). Otro tipo iterable que ya conocemos es ( range ). Incluso, como programadores, podemos definir objetos que sean iterables de esta manera. for contador in range ( 5 ): print ( contador ) # >> 0 1 2 3 4 for cadena in [ 'hola' , 'adios' , 'buenas' ]: print ( cadena ) # >> hola adios buenas for cadena in ( 'tupla' , 'de' , 'cuatro' , 'elementos' ): print ( cadena ) # >> tupla de cuatro elementos for caracter in 'cadena' : print ( caracter ) # >> c a d e n a for clave in { 'software libre' : 'bien!' , 'software privativo' : 'mal :(' }: print ( clave ) # >> software libre software privativo Podemos transformar cualquier iterable a una lista usando casting . Esto normalmente no es necesario y es mucho m\u00e1s eficiente trabajar directamente con el iterable, ya que no necesitamos reservar memoria para la lista, pero hay situaciones donde quiz\u00e1 lo necesitemos. list ( range ( 15 )) # >> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14] Sin necesidad de importar ning\u00fan m\u00f3dulo, Python ofrece varias utilidades (llamadas built-ins ) para trabajar con iteradores. La mayor\u00eda de estas funciones reciben un iterable y devuelven otro iterable: def doble ( x ): return x * 2 # \"map\" aplica una funci\u00f3n a cada objeto del iterable list ( map ( doble , range ( 10 )) ) # >> [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] # \"filter\" se salta los elementos que no cumplan una condici\u00f3n def es_par ( numero ): return ( numero % 2 ) == 0 list ( filter ( es_par , range ( 10 )) ) # >> [0, 2, 4, 6, 8] # \"sum\" calcula la suma de los elementos de un iterable sum ( range ( 10 )) # >> 45 # Podemos combinar ambos: sum ( map ( doble , range ( 10 ))) # >> 90 # \"max\" y \"min\": M\u00e1ximo y m\u00ednimo elemento min ( range ( 10 , 20 )) # >> 10 max ( range ( 10 , 20 )) # >> 19 # \"zip\" une dos iterables distintos nombres = [ 'alice' , 'bob' , 'carol' ] pseudonimos = [ 'A' , 'B' , 'C' ] list ( zip ( nombres , pseudonimos )) # >> [('alice', 'A'), ('bob', 'B'), ('carol', 'C')] for nombre , pseudonimo in zip ( nombres , pseudonimos ): print ( f ' { nombre } : { pseudonimo } ' ) # >> alice: A # >> bob: B # >> carol: C # \"enumerate\" adjunta un \u00edndice a cada elemento for i , nombre in enumerate ( nombres ): print ( f ' { i } : { nombre } ' ) # >> 0: alice # >> 1: bob # >> 2: carol En el m\u00f3dulo itertools ( Documentaci\u00f3n ) tenemos muchas m\u00e1s operaciones sobre iterables. Combinando todas estas, podemos hacer casi de todo: import itertools # Iteradores infinitos # (para detener, pulsar Ctrl+C) for i in itertools . count ( start = 1 , step = 2 ): # Como \"range\" pero sin final print ( i ) # >> 1 3 5 7 9 11 ... for i in itertools . cycle ( nombres ): print ( i ) # >> alice bob carol alice bob carol ... # Combinatoria for numero , nombre in itertools . product ( range ( 2 ), nombres ): print ( f ' { numero } { nombre } ' ) # >> 0 alice # >> 0 bob # >> 0 carol # >> 1 alice # >> 1 bob # >> 1 carol for permutacion in itertools . permutations ( nombres ): print ( permutacion ) # >> ('alice', 'bob', 'carol') # >> ('alice', 'carol', 'bob') # >> ('bob', 'alice', 'carol') # >> ('bob', 'carol', 'alice') # >> ('carol', 'alice', 'bob') # >> ('carol', 'bob', 'alice') for pareja in itertools . combinations ( nombres , 2 ): print ( pareja ) # >> ('alice', 'bob') # >> ('alice', 'carol') # >> ('bob', 'carol') Nota Si no entiendes c\u00f3mo funciona alguna de las funciones de itertools , en la documentaci\u00f3n tienes una peque\u00f1a implementaci\u00f3n de cada una para que puedas analizarla paso por paso. Consejo Los iterables y las operaciones sobre ellos son una de las herramientas m\u00e1s potentes de Python, con las que puedes hacer casi de todo de forma muy escueta y elegante. Aprende a usarlos, practica mucho y ver\u00e1s como tus habilidades programando mejoran much\u00edsimo. Cuando expresas la soluci\u00f3n a un problema mediante iterables y estas operaciones \u00a1quiz\u00e1 aprendas algo nuevo sobre el problema que no sab\u00edas antes!","title":"Iteradores: `itertools`"},{"location":"M%C3%B3dulos/04-itertools/#iteradores-itertools","text":"En Python llamamos iterable a todo aquel objeto que podemos recorrer mediante un bucle for : for elemento in iterable : func ( elemento ) Esto por supuesto incluye listas ( list ), pero tambi\u00e9n tuplas ( tuple ), cadenas ( str ) e incluso elementos que no tienen un orden predeterminado como diccionarios ( dict ) o conjuntos ( set ). Otro tipo iterable que ya conocemos es ( range ). Incluso, como programadores, podemos definir objetos que sean iterables de esta manera. for contador in range ( 5 ): print ( contador ) # >> 0 1 2 3 4 for cadena in [ 'hola' , 'adios' , 'buenas' ]: print ( cadena ) # >> hola adios buenas for cadena in ( 'tupla' , 'de' , 'cuatro' , 'elementos' ): print ( cadena ) # >> tupla de cuatro elementos for caracter in 'cadena' : print ( caracter ) # >> c a d e n a for clave in { 'software libre' : 'bien!' , 'software privativo' : 'mal :(' }: print ( clave ) # >> software libre software privativo Podemos transformar cualquier iterable a una lista usando casting . Esto normalmente no es necesario y es mucho m\u00e1s eficiente trabajar directamente con el iterable, ya que no necesitamos reservar memoria para la lista, pero hay situaciones donde quiz\u00e1 lo necesitemos. list ( range ( 15 )) # >> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14] Sin necesidad de importar ning\u00fan m\u00f3dulo, Python ofrece varias utilidades (llamadas built-ins ) para trabajar con iteradores. La mayor\u00eda de estas funciones reciben un iterable y devuelven otro iterable: def doble ( x ): return x * 2 # \"map\" aplica una funci\u00f3n a cada objeto del iterable list ( map ( doble , range ( 10 )) ) # >> [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] # \"filter\" se salta los elementos que no cumplan una condici\u00f3n def es_par ( numero ): return ( numero % 2 ) == 0 list ( filter ( es_par , range ( 10 )) ) # >> [0, 2, 4, 6, 8] # \"sum\" calcula la suma de los elementos de un iterable sum ( range ( 10 )) # >> 45 # Podemos combinar ambos: sum ( map ( doble , range ( 10 ))) # >> 90 # \"max\" y \"min\": M\u00e1ximo y m\u00ednimo elemento min ( range ( 10 , 20 )) # >> 10 max ( range ( 10 , 20 )) # >> 19 # \"zip\" une dos iterables distintos nombres = [ 'alice' , 'bob' , 'carol' ] pseudonimos = [ 'A' , 'B' , 'C' ] list ( zip ( nombres , pseudonimos )) # >> [('alice', 'A'), ('bob', 'B'), ('carol', 'C')] for nombre , pseudonimo in zip ( nombres , pseudonimos ): print ( f ' { nombre } : { pseudonimo } ' ) # >> alice: A # >> bob: B # >> carol: C # \"enumerate\" adjunta un \u00edndice a cada elemento for i , nombre in enumerate ( nombres ): print ( f ' { i } : { nombre } ' ) # >> 0: alice # >> 1: bob # >> 2: carol En el m\u00f3dulo itertools ( Documentaci\u00f3n ) tenemos muchas m\u00e1s operaciones sobre iterables. Combinando todas estas, podemos hacer casi de todo: import itertools # Iteradores infinitos # (para detener, pulsar Ctrl+C) for i in itertools . count ( start = 1 , step = 2 ): # Como \"range\" pero sin final print ( i ) # >> 1 3 5 7 9 11 ... for i in itertools . cycle ( nombres ): print ( i ) # >> alice bob carol alice bob carol ... # Combinatoria for numero , nombre in itertools . product ( range ( 2 ), nombres ): print ( f ' { numero } { nombre } ' ) # >> 0 alice # >> 0 bob # >> 0 carol # >> 1 alice # >> 1 bob # >> 1 carol for permutacion in itertools . permutations ( nombres ): print ( permutacion ) # >> ('alice', 'bob', 'carol') # >> ('alice', 'carol', 'bob') # >> ('bob', 'alice', 'carol') # >> ('bob', 'carol', 'alice') # >> ('carol', 'alice', 'bob') # >> ('carol', 'bob', 'alice') for pareja in itertools . combinations ( nombres , 2 ): print ( pareja ) # >> ('alice', 'bob') # >> ('alice', 'carol') # >> ('bob', 'carol') Nota Si no entiendes c\u00f3mo funciona alguna de las funciones de itertools , en la documentaci\u00f3n tienes una peque\u00f1a implementaci\u00f3n de cada una para que puedas analizarla paso por paso. Consejo Los iterables y las operaciones sobre ellos son una de las herramientas m\u00e1s potentes de Python, con las que puedes hacer casi de todo de forma muy escueta y elegante. Aprende a usarlos, practica mucho y ver\u00e1s como tus habilidades programando mejoran much\u00edsimo. Cuando expresas la soluci\u00f3n a un problema mediante iterables y estas operaciones \u00a1quiz\u00e1 aprendas algo nuevo sobre el problema que no sab\u00edas antes!","title":"Iteradores: itertools"},{"location":"M%C3%B3dulos/05-copy/","text":"Copiado de objetos: copy \u00b6 Documentaci\u00f3n En Python, por defecto, todos los valores son referencias a un objeto. Si copiamos una referencia a un objeto mutable (es decir, que puede ser modificado), por ejemplo una lista, ambas copias se refieren a la misma lista. Por ejemplo: a = [ 'hola' , 'adios' , 'buenas' ] b = a # Copiamos la referencia, NO SE HACE COPIA b [ 0 ] = 'hastaluego' # Estamos modificando la lista original print ( a ) # >> ['hastaluego', 'adios', 'buenas'] print ( b ) # >> ['hastaluego', 'adios', 'buenas'] Si, por alg\u00fan motivo, necesitamos tener copias independientes, podemos hacer copias usando el m\u00f3dulo copy : import copy a = [ 'hola' , 'adios' , 'buenas' ] b = copy . copy ( a ) # Creamos una copia de la lista b [ 0 ] = 'hastaluego' # Estamos modificando la copia print ( a ) # >> ['hola', 'adios', 'buenas'] print ( b ) # >> ['hastaluego', 'adios', 'buenas'] \u00a1Mucho ojo con objetos anidados! En el siguiente ejemplo tenemos una lista de listas . Si simplemente copiamos la lista externa, ambas listas contienen referencias a las mismas listas. a = [[ 1 , 2 ], [ 3 , 4 ], [ 5 , 6 ]] b = copy . copy ( a ) # Copiamos las referencias, pero apunta a las mismas listas b [ 0 ][ 1 ] = 10 # Ojo, estamos cambiando la primera lista print ( a ) # >> [[1, 10], [3, 4], [5, 6]] Ejercicio Un buen ejercicio para practicar el pensamiento recursivo es implementar una funci\u00f3n de copia profunda (equivalente a copy.deepcopy() ) usando \u00fanicamente la funci\u00f3n de copia copy.copy() . \u00a1Int\u00e9ntalo! Si esto no es lo que queremos, tenemos que hacer una copia profunda o \"deep copy\" (es decir, \u00a1una copia recursiva!): a = [[ 1 , 2 ], [ 3 , 4 ], [ 5 , 6 ]] b = copy . deepcopy ( a ) b [ 0 ][ 1 ] = 10 print ( a ) # >> [[1, 2], [3, 4], [5, 6]] print ( b ) # >> [[1, 10], [3, 4], [5, 6]]","title":"Copiado de objetos: `copy`"},{"location":"M%C3%B3dulos/05-copy/#copiado-de-objetos-copy","text":"Documentaci\u00f3n En Python, por defecto, todos los valores son referencias a un objeto. Si copiamos una referencia a un objeto mutable (es decir, que puede ser modificado), por ejemplo una lista, ambas copias se refieren a la misma lista. Por ejemplo: a = [ 'hola' , 'adios' , 'buenas' ] b = a # Copiamos la referencia, NO SE HACE COPIA b [ 0 ] = 'hastaluego' # Estamos modificando la lista original print ( a ) # >> ['hastaluego', 'adios', 'buenas'] print ( b ) # >> ['hastaluego', 'adios', 'buenas'] Si, por alg\u00fan motivo, necesitamos tener copias independientes, podemos hacer copias usando el m\u00f3dulo copy : import copy a = [ 'hola' , 'adios' , 'buenas' ] b = copy . copy ( a ) # Creamos una copia de la lista b [ 0 ] = 'hastaluego' # Estamos modificando la copia print ( a ) # >> ['hola', 'adios', 'buenas'] print ( b ) # >> ['hastaluego', 'adios', 'buenas'] \u00a1Mucho ojo con objetos anidados! En el siguiente ejemplo tenemos una lista de listas . Si simplemente copiamos la lista externa, ambas listas contienen referencias a las mismas listas. a = [[ 1 , 2 ], [ 3 , 4 ], [ 5 , 6 ]] b = copy . copy ( a ) # Copiamos las referencias, pero apunta a las mismas listas b [ 0 ][ 1 ] = 10 # Ojo, estamos cambiando la primera lista print ( a ) # >> [[1, 10], [3, 4], [5, 6]] Ejercicio Un buen ejercicio para practicar el pensamiento recursivo es implementar una funci\u00f3n de copia profunda (equivalente a copy.deepcopy() ) usando \u00fanicamente la funci\u00f3n de copia copy.copy() . \u00a1Int\u00e9ntalo! Si esto no es lo que queremos, tenemos que hacer una copia profunda o \"deep copy\" (es decir, \u00a1una copia recursiva!): a = [[ 1 , 2 ], [ 3 , 4 ], [ 5 , 6 ]] b = copy . deepcopy ( a ) b [ 0 ][ 1 ] = 10 print ( a ) # >> [[1, 2], [3, 4], [5, 6]] print ( b ) # >> [[1, 10], [3, 4], [5, 6]]","title":"Copiado de objetos: copy"},{"location":"M%C3%B3dulos/06-random/","text":"Generadores aleatorios: random \u00b6 Documentaci\u00f3n A veces nuestro programa necesita implementar alg\u00fan tipo de comportamiento (aparentemente) aleatorio. Python dispone de un mont\u00f3n de utilidades para esto en el m\u00f3dulo random . \u00a1Cuidado! Las funciones que se presentan aqu\u00ed generan n\u00fameros y secuencias pseudo -aleatorias. Estas son muy \u00fatiles para situaciones donde algo s\u00f3lo debe aparentar ser aleatorio (por ejemplo: un efecto gr\u00e1fico, el da\u00f1o realizado a un enemigo en un videojuego, una simulaci\u00f3n f\u00edsica, etc.). Para aplicaciones donde la seguridad de la informaci\u00f3n est\u00e9 en juego (por ejemplo, un algoritmo de cifrado de mensajes secretos, una bajara virtual de p\u00f3ker de un casino online, etc.) el m\u00f3dulo random NO ES ADECUADO . En esos casos es necesario encontrar una verdadera fuente de aleatoriedad sin sesgos. Por defecto, al importar random , el int\u00e9rprete toma la \"semilla\" para generar n\u00fameros aleatorios de una fuente de aleatoriedad del sistema. Nosotros podemos especificar la semilla que queramos si, por ejemplo, queremos que nuestro c\u00f3digo sea reproducible. import random random . seed ( 123 ) Disponemos de varias funciones para generar n\u00fameros aleatorios de distinta \u00edndole: # Generar valores flotantes en el rango [0.0, 1.0) random . random () # >> 0.052363598850944326 # Generar valores enteros en el rango [a, b) random . randrange ( 8 ) # Si solo ponemos un argumento, por defecto toma [0, a) # >> 1 # O si queremos un rango cerrado en ambos extremos [a, b] random . randint ( 2 , 8 ) # >> 8 Tambi\u00e9n tenemos m\u00faltiples operaciones para obtener elementos aleatorios ( muestras ) de listas: lista = [ 'alice' , 'bob' , 'carol' , 'eva' ] # Elegir un elemento aleatorio de una lista random . choice ( lista ) # >> eva # Lo anterior es una manera m\u00e1s compacta de escribir: lista [ random . randrange ( len ( lista ))] # >> carol # Elegir varios elementos aletorios de una lista CON REEMPLAZO # Es decir, pueden salir elementos repetidos random . choices ( lista , k = 3 ) # >> ['alice', 'eva', 'alice'] # Si no queremos elementos repetidos: random . sample ( lista , 3 ) # >> ['carol', 'bob', 'alice'] Por \u00faltimo, tambi\u00e9n podemos desordenar una lista: lista # >> ['alice', 'bob', 'carol', 'eva'] # Desordenar la lista random . shuffle ( lista ) lista # >> ['carol', 'eva', 'alice', 'bob']","title":"Generadores aleatorios: `random`"},{"location":"M%C3%B3dulos/06-random/#generadores-aleatorios-random","text":"Documentaci\u00f3n A veces nuestro programa necesita implementar alg\u00fan tipo de comportamiento (aparentemente) aleatorio. Python dispone de un mont\u00f3n de utilidades para esto en el m\u00f3dulo random . \u00a1Cuidado! Las funciones que se presentan aqu\u00ed generan n\u00fameros y secuencias pseudo -aleatorias. Estas son muy \u00fatiles para situaciones donde algo s\u00f3lo debe aparentar ser aleatorio (por ejemplo: un efecto gr\u00e1fico, el da\u00f1o realizado a un enemigo en un videojuego, una simulaci\u00f3n f\u00edsica, etc.). Para aplicaciones donde la seguridad de la informaci\u00f3n est\u00e9 en juego (por ejemplo, un algoritmo de cifrado de mensajes secretos, una bajara virtual de p\u00f3ker de un casino online, etc.) el m\u00f3dulo random NO ES ADECUADO . En esos casos es necesario encontrar una verdadera fuente de aleatoriedad sin sesgos. Por defecto, al importar random , el int\u00e9rprete toma la \"semilla\" para generar n\u00fameros aleatorios de una fuente de aleatoriedad del sistema. Nosotros podemos especificar la semilla que queramos si, por ejemplo, queremos que nuestro c\u00f3digo sea reproducible. import random random . seed ( 123 ) Disponemos de varias funciones para generar n\u00fameros aleatorios de distinta \u00edndole: # Generar valores flotantes en el rango [0.0, 1.0) random . random () # >> 0.052363598850944326 # Generar valores enteros en el rango [a, b) random . randrange ( 8 ) # Si solo ponemos un argumento, por defecto toma [0, a) # >> 1 # O si queremos un rango cerrado en ambos extremos [a, b] random . randint ( 2 , 8 ) # >> 8 Tambi\u00e9n tenemos m\u00faltiples operaciones para obtener elementos aleatorios ( muestras ) de listas: lista = [ 'alice' , 'bob' , 'carol' , 'eva' ] # Elegir un elemento aleatorio de una lista random . choice ( lista ) # >> eva # Lo anterior es una manera m\u00e1s compacta de escribir: lista [ random . randrange ( len ( lista ))] # >> carol # Elegir varios elementos aletorios de una lista CON REEMPLAZO # Es decir, pueden salir elementos repetidos random . choices ( lista , k = 3 ) # >> ['alice', 'eva', 'alice'] # Si no queremos elementos repetidos: random . sample ( lista , 3 ) # >> ['carol', 'bob', 'alice'] Por \u00faltimo, tambi\u00e9n podemos desordenar una lista: lista # >> ['alice', 'bob', 'carol', 'eva'] # Desordenar la lista random . shuffle ( lista ) lista # >> ['carol', 'eva', 'alice', 'bob']","title":"Generadores aleatorios: random"},{"location":"M%C3%B3dulos/07-datetime/","text":"Tiempo, fechas y horas: time , datetime , calendar \u00b6 A menudo necesitamos utilidades para calcular tiempos, horas, fechas, etc. En Python lo tenemos muy f\u00e1cil gracias a estos tres m\u00f3dulos. Las funciones del m\u00f3dulo time est\u00e1n relacionadas con tiempos de espera y tiempos de c\u00f3mputo. Por ejemplo, time.perf_counter() mide tiempo real, incluyendo tiempo de inactividad. S\u00f3lo tiene sentido si calculamos una diferencia entre dos llamadas : import time import math inicio = time . perf_counter () # Empezamos el \"cron\u00f3metro\" fact = math . factorial ( 100000 ) # C\u00e1lculo largo print ( str ( fact )[: 10 ]) # Primeros 10 d\u00edgitos # >> 2824229407 fin_factorial = time . perf_counter () # Fin del c\u00e1lculo largo time . sleep ( 1 ) # Ahora un segundo de inactividad fin = time . perf_counter () # Paramos el \"cron\u00f3metro\" print ( f 'Tiempo de c\u00e1lculo: { fin_factorial - inicio : .2f } segundos' ) print ( f 'Tiempo total: { fin - inicio : .2f } segundos' ) # >> Tiempo de c\u00e1lculo: 2.38 segundos # >> Tiempo total: 3.38 segundos Por otro lado, time.process_time() mide tiempo de proceso , sin incluir el tiempo que el proceso est\u00e1 inactivo (por ejemplo, esperando a que el usuario introduzca alg\u00fan valor o esperando a alg\u00fan dispositivo de E/S): import time import math inicio = time . process_time () # Empezamos el \"cron\u00f3metro\" fact = math . factorial ( 100000 ) # C\u00e1lculo largo print ( str ( fact )[: 10 ]) # Primeros 10 d\u00edgitos # >> 2824229407 fin_factorial = time . process_time () # Fin del c\u00e1lculo largo time . sleep ( 1 ) # Ahora un segundo de inactividad fin = time . process_time () # Paramos el \"cron\u00f3metro\" print ( f 'Tiempo de c\u00e1lculo: { fin_factorial - inicio : .2f } segundos' ) print ( f 'Tiempo total: { fin - inicio : .2f } segundos' ) # >> Tiempo de c\u00e1lculo: 2.44 segundos # >> Tiempo total: 2.45 segundos Informaci\u00f3n La peque\u00f1a discrepancia en el tiempo de c\u00e1lculo y tiempo total del \u00faltimo ejemplo se debe a que la propia llamada a time.sleep(1) , as\u00ed como time.process_time() , tiene cierta sobrecarga . Podemos usar datetime para lidiar con fechas y horas del \"mundo real\": from datetime import datetime # Mi fecha de nacimiento nacimiento = datetime ( 1995 , 4 , 22 , 6 , 0 ) print ( nacimiento . weekday ()) # \u00bfQu\u00e9 d\u00eda de la semana? (0 = lunes) # >> 5 # \u00bfCu\u00e1ntos a\u00f1os tengo? (datetime - datetime = timedelta) td = datetime . now () - nacimiento print ( td ) # >> 9473 days, 13:30:38.442574 print ( td . days // 365 ) # >> 25 print ( td . total_seconds ()) # >> 818515838.442574 Por \u00faltimo calendar contiene utilidades relacionadas con calendarios: a\u00f1os bisiestos, nombres de los meses/d\u00edas de la semana... import calendar # Para configurar la localizaci\u00f3n de fecha/hora a Espa\u00f1a, # tenemos que ejecutar lo siguiente: import locale locale . setlocale ( locale . LC_TIME , 'es_ES.UTF-8' ) nombre_dia_semana = calendar . day_name [ nacimiento . weekday ()] nombre_dia_mes = calendar . month_name [ nacimiento . month ] print ( f 'Nac\u00ed un { nombre_dia_semana } , { nacimiento . day } de { nombre_dia_mes } de { nacimiento . year } ' ) # >> Nac\u00ed un s\u00e1bado, 22 de abril de 1995 Cuidado Si tu aplicaci\u00f3n necesita gestionar m\u00e1s de una localizaci\u00f3n (p. ej.: espa\u00f1ol de Espa\u00f1a y espa\u00f1ol de M\u00e9xico) se desaconseja el uso de locale.setlocale() . Este es s\u00f3lo un peque\u00f1o ejemplo.","title":"Tiempo, fechas y horas: `time`, `datetime`, `calendar`"},{"location":"M%C3%B3dulos/07-datetime/#tiempo-fechas-y-horas-time-datetime-calendar","text":"A menudo necesitamos utilidades para calcular tiempos, horas, fechas, etc. En Python lo tenemos muy f\u00e1cil gracias a estos tres m\u00f3dulos. Las funciones del m\u00f3dulo time est\u00e1n relacionadas con tiempos de espera y tiempos de c\u00f3mputo. Por ejemplo, time.perf_counter() mide tiempo real, incluyendo tiempo de inactividad. S\u00f3lo tiene sentido si calculamos una diferencia entre dos llamadas : import time import math inicio = time . perf_counter () # Empezamos el \"cron\u00f3metro\" fact = math . factorial ( 100000 ) # C\u00e1lculo largo print ( str ( fact )[: 10 ]) # Primeros 10 d\u00edgitos # >> 2824229407 fin_factorial = time . perf_counter () # Fin del c\u00e1lculo largo time . sleep ( 1 ) # Ahora un segundo de inactividad fin = time . perf_counter () # Paramos el \"cron\u00f3metro\" print ( f 'Tiempo de c\u00e1lculo: { fin_factorial - inicio : .2f } segundos' ) print ( f 'Tiempo total: { fin - inicio : .2f } segundos' ) # >> Tiempo de c\u00e1lculo: 2.38 segundos # >> Tiempo total: 3.38 segundos Por otro lado, time.process_time() mide tiempo de proceso , sin incluir el tiempo que el proceso est\u00e1 inactivo (por ejemplo, esperando a que el usuario introduzca alg\u00fan valor o esperando a alg\u00fan dispositivo de E/S): import time import math inicio = time . process_time () # Empezamos el \"cron\u00f3metro\" fact = math . factorial ( 100000 ) # C\u00e1lculo largo print ( str ( fact )[: 10 ]) # Primeros 10 d\u00edgitos # >> 2824229407 fin_factorial = time . process_time () # Fin del c\u00e1lculo largo time . sleep ( 1 ) # Ahora un segundo de inactividad fin = time . process_time () # Paramos el \"cron\u00f3metro\" print ( f 'Tiempo de c\u00e1lculo: { fin_factorial - inicio : .2f } segundos' ) print ( f 'Tiempo total: { fin - inicio : .2f } segundos' ) # >> Tiempo de c\u00e1lculo: 2.44 segundos # >> Tiempo total: 2.45 segundos Informaci\u00f3n La peque\u00f1a discrepancia en el tiempo de c\u00e1lculo y tiempo total del \u00faltimo ejemplo se debe a que la propia llamada a time.sleep(1) , as\u00ed como time.process_time() , tiene cierta sobrecarga . Podemos usar datetime para lidiar con fechas y horas del \"mundo real\": from datetime import datetime # Mi fecha de nacimiento nacimiento = datetime ( 1995 , 4 , 22 , 6 , 0 ) print ( nacimiento . weekday ()) # \u00bfQu\u00e9 d\u00eda de la semana? (0 = lunes) # >> 5 # \u00bfCu\u00e1ntos a\u00f1os tengo? (datetime - datetime = timedelta) td = datetime . now () - nacimiento print ( td ) # >> 9473 days, 13:30:38.442574 print ( td . days // 365 ) # >> 25 print ( td . total_seconds ()) # >> 818515838.442574 Por \u00faltimo calendar contiene utilidades relacionadas con calendarios: a\u00f1os bisiestos, nombres de los meses/d\u00edas de la semana... import calendar # Para configurar la localizaci\u00f3n de fecha/hora a Espa\u00f1a, # tenemos que ejecutar lo siguiente: import locale locale . setlocale ( locale . LC_TIME , 'es_ES.UTF-8' ) nombre_dia_semana = calendar . day_name [ nacimiento . weekday ()] nombre_dia_mes = calendar . month_name [ nacimiento . month ] print ( f 'Nac\u00ed un { nombre_dia_semana } , { nacimiento . day } de { nombre_dia_mes } de { nacimiento . year } ' ) # >> Nac\u00ed un s\u00e1bado, 22 de abril de 1995 Cuidado Si tu aplicaci\u00f3n necesita gestionar m\u00e1s de una localizaci\u00f3n (p. ej.: espa\u00f1ol de Espa\u00f1a y espa\u00f1ol de M\u00e9xico) se desaconseja el uso de locale.setlocale() . Este es s\u00f3lo un peque\u00f1o ejemplo.","title":"Tiempo, fechas y horas: time, datetime, calendar"},{"location":"Python_Avanzado/Argumentos/","text":"Argumentos \u00b6 En Python existen distintos tipos de argumentos que debemos de conocer ya que entenderlos nos ayudar\u00e1 much\u00edsimo a la hora de programar y de consultar la documentaci\u00f3n. En concreto debemos de distinguir entre: Los argumentos posicionales: son argumentos que se pueden llamar por su posici\u00f3n en la definici\u00f3n de la funci\u00f3n. Los argumentos de palabras: clave son argumentos que se pueden llamar por su nombre. Los argumentos obligatorios: son argumentos que se deben pasar a la funci\u00f3n. Los argumentos opcionales: son argumentos que no es necesario especificar. En Python, los argumentos opcionales son argumentos que tienen un valor predeterminado. La forma en que se pasa el valor a la funci\u00f3n determina si son argumentos posicionales o argumentos de palabra clave . Por ejemplo, las tres siguientes llamadas a la funci\u00f3n rectangleArea() ser\u00edan v\u00e1lidas y devolver\u00edan el mismo resultado. def rectangleArea ( width , height ): return width * height rectangleArea ( 1 , 2 ) # positional arguments rectangleArea ( height = 2 , width = 1 ) # keyword arguments rectangleArea ( width = 1 , height = 2 ) # keyword arguments Una vez hemos entendido ese concepto y las diferencias de significados entre los distintos tipos podemos combinarlos como queramos aqu\u00ed teneis algunos ejemplos: Argumento posicional que es opcional \u00b6 def f ( a = 2 , / ): pass f () # Allowed, argument is optional f ( 1 ) # Allowed, it's a positional argument f ( a = 1 ) # Error, positional only argument Argumento posicional que se requiere \u00b6 def f ( a , / ): pass f () # Error, argument required f ( 1 ) # Allowed, it's a positional argument f ( a = 1 ) # Error, positional only argument Argumento de palabra clave que es opcional \u00b6 def f ( * , a = 1 ): pass f () # Allowed f ( 1 ) # Error, keyword only arguments f ( a = 1 ) # Allowed, it's a keyword argument Argumento de palabra clave que se requiere \u00b6 def f ( * , a ) pass f () # Error, argument required f ( 1 ) # Error, keyword only arguments f ( a = 1 ) # Allowed, it's a keyword argument Argumento posicional y de palabra clave que es opcional \u00b6 def f ( a = 1 ) pass f () # Allowed, argument is optional f ( 1 ) # Allowed, it's a positional argument f ( a = 1 ) # Allowed, it's a keyword argument # De hecho esta funcion equivale a: def f ( * , a = 1 , / ): pass Argumento posicional y de palabra clave que se requiere \u00b6 def f ( a ): pass f () # Error, argument required f ( 1 ) # Allowed, it's a positional argument f ( a = 1 ) # Allowed, it's a keyword argument # De hecho esta funcion equivale a: def f ( * , a , / ): pass","title":"Argumentos"},{"location":"Python_Avanzado/Argumentos/#argumentos","text":"En Python existen distintos tipos de argumentos que debemos de conocer ya que entenderlos nos ayudar\u00e1 much\u00edsimo a la hora de programar y de consultar la documentaci\u00f3n. En concreto debemos de distinguir entre: Los argumentos posicionales: son argumentos que se pueden llamar por su posici\u00f3n en la definici\u00f3n de la funci\u00f3n. Los argumentos de palabras: clave son argumentos que se pueden llamar por su nombre. Los argumentos obligatorios: son argumentos que se deben pasar a la funci\u00f3n. Los argumentos opcionales: son argumentos que no es necesario especificar. En Python, los argumentos opcionales son argumentos que tienen un valor predeterminado. La forma en que se pasa el valor a la funci\u00f3n determina si son argumentos posicionales o argumentos de palabra clave . Por ejemplo, las tres siguientes llamadas a la funci\u00f3n rectangleArea() ser\u00edan v\u00e1lidas y devolver\u00edan el mismo resultado. def rectangleArea ( width , height ): return width * height rectangleArea ( 1 , 2 ) # positional arguments rectangleArea ( height = 2 , width = 1 ) # keyword arguments rectangleArea ( width = 1 , height = 2 ) # keyword arguments Una vez hemos entendido ese concepto y las diferencias de significados entre los distintos tipos podemos combinarlos como queramos aqu\u00ed teneis algunos ejemplos:","title":"Argumentos"},{"location":"Python_Avanzado/Argumentos/#argumento-posicional-que-es-opcional","text":"def f ( a = 2 , / ): pass f () # Allowed, argument is optional f ( 1 ) # Allowed, it's a positional argument f ( a = 1 ) # Error, positional only argument","title":"Argumento posicional que es opcional"},{"location":"Python_Avanzado/Argumentos/#argumento-posicional-que-se-requiere","text":"def f ( a , / ): pass f () # Error, argument required f ( 1 ) # Allowed, it's a positional argument f ( a = 1 ) # Error, positional only argument","title":"Argumento posicional que se requiere"},{"location":"Python_Avanzado/Argumentos/#argumento-de-palabra-clave-que-es-opcional","text":"def f ( * , a = 1 ): pass f () # Allowed f ( 1 ) # Error, keyword only arguments f ( a = 1 ) # Allowed, it's a keyword argument","title":"Argumento de palabra clave que es opcional"},{"location":"Python_Avanzado/Argumentos/#argumento-de-palabra-clave-que-se-requiere","text":"def f ( * , a ) pass f () # Error, argument required f ( 1 ) # Error, keyword only arguments f ( a = 1 ) # Allowed, it's a keyword argument","title":"Argumento de palabra clave que se requiere"},{"location":"Python_Avanzado/Argumentos/#argumento-posicional-y-de-palabra-clave-que-es-opcional","text":"def f ( a = 1 ) pass f () # Allowed, argument is optional f ( 1 ) # Allowed, it's a positional argument f ( a = 1 ) # Allowed, it's a keyword argument # De hecho esta funcion equivale a: def f ( * , a = 1 , / ): pass","title":"Argumento posicional y de palabra clave que es opcional"},{"location":"Python_Avanzado/Argumentos/#argumento-posicional-y-de-palabra-clave-que-se-requiere","text":"def f ( a ): pass f () # Error, argument required f ( 1 ) # Allowed, it's a positional argument f ( a = 1 ) # Allowed, it's a keyword argument # De hecho esta funcion equivale a: def f ( * , a , / ): pass","title":"Argumento posicional y de palabra clave que se requiere"},{"location":"Python_Avanzado/Clases/","text":"Clases \u00b6 La Programaci\u00f3n Orientada a Objetos es un paradigma de programaci\u00f3n que viene a innovar la forma de obtener resultados. Los objetos se utilizan como met\u00e1fora para emular las entidades reales del negocio a modelar. Muchos de los objetos predise\u00f1ados de los lenguajes de programaci\u00f3n actuales permiten la agrupaci\u00f3n en bibliotecas o librer\u00edas, sin embargo, muchos de estos lenguajes permiten al usuario la creaci\u00f3n de sus propias bibliotecas. Est\u00e1 basada en varias t\u00e9cnicas del sexenio: herencia, cohesi\u00f3n, abstracci\u00f3n, polimorfismo, acoplamiento y encapsulamiento. Su uso se populariz\u00f3 a principios de la d\u00e9cada de 1990 y en la actualidad resulta imprescindible para todo programador. \u00bfComo creamos una clase en Python? \u00b6 Pues es muy sencillo ya que la sintaxis como siempre es muy similar a la de otros lenguajes. En este caso vamos a poner un ejemplo creando una clase persona de la que heredar\u00e1 la clase inform\u00e1tico. Y lo \u00fanico que debemos de tener presente es que a diferencia de C++ que lo pone autom\u00e1ticamente en Python las funciones de la clase reciben como par\u00e1metro el objeto que las llama es por eso que ponemos self . Ser\u00eda equivalente al puntero this en C++. class Persona : #Clase persona def __init__ ( self , nombre , apellidos , altura , edad ): #Constructor self . nombre_ = nombre self . apellidos_ = apellidos self . altura_ = altura self . edad_ = edad def getnombre ( self ): #Observador que devuelve el nombre_ de la persona return self . nombre_ def getapellidos ( self ): #Observador que devuelve los apellidos_ de la persona return self . apellidos_ def getaltura ( self ): #Observador que devuelve la altura_ de la persona return self . altura_ def getedad ( self ): #Observador que devuelve el nombre_ de la persona return self . edad_ def setnombre ( self , nombre ): #Modificador que permite cambiar el nombre_ de la persona self . nombre_ = nombre def setapellidos ( self , apellidos ): #Modificador que permite cambiar los apellidos_ de la persona self . apellidos_ = apellidos def setaltura ( self , altura ): #Modificador que permite cambiar la altura_ de la persona self . altura_ = altura def setedad ( self , edad ): #Modificador que permite cambiar la edad_ de la persona self . edad_ = edad def hablar ( self ): #Metodo de la clase return \"Estoy hablando\" def caminar ( self ): #Metodo de la clase return \"Estoy caminando\" def dormir ( self ): #Metodo de la clase return \"zZz\" class Informatico ( Persona ): # Inform\u00e1tico hereda de forma p\u00fablica de persona lenguajes_ experiencia_ def __init__ ( self , lenguajes , experiencia ): self . lenguajes_ = lenguajes self . experiencia_ = experiencia def getLenguajes ( self ): return self . lenguajes_ def aprender ( self , lenguajes ): self . lenguajes_ = lenguajes return self . lenguajes_ def programar ( self ): return \"Estoy programando\" def repararPC ( self ): return \"He reparado tu pc\"","title":"Clases"},{"location":"Python_Avanzado/Clases/#clases","text":"La Programaci\u00f3n Orientada a Objetos es un paradigma de programaci\u00f3n que viene a innovar la forma de obtener resultados. Los objetos se utilizan como met\u00e1fora para emular las entidades reales del negocio a modelar. Muchos de los objetos predise\u00f1ados de los lenguajes de programaci\u00f3n actuales permiten la agrupaci\u00f3n en bibliotecas o librer\u00edas, sin embargo, muchos de estos lenguajes permiten al usuario la creaci\u00f3n de sus propias bibliotecas. Est\u00e1 basada en varias t\u00e9cnicas del sexenio: herencia, cohesi\u00f3n, abstracci\u00f3n, polimorfismo, acoplamiento y encapsulamiento. Su uso se populariz\u00f3 a principios de la d\u00e9cada de 1990 y en la actualidad resulta imprescindible para todo programador.","title":"Clases"},{"location":"Python_Avanzado/Clases/#como-creamos-una-clase-en-python","text":"Pues es muy sencillo ya que la sintaxis como siempre es muy similar a la de otros lenguajes. En este caso vamos a poner un ejemplo creando una clase persona de la que heredar\u00e1 la clase inform\u00e1tico. Y lo \u00fanico que debemos de tener presente es que a diferencia de C++ que lo pone autom\u00e1ticamente en Python las funciones de la clase reciben como par\u00e1metro el objeto que las llama es por eso que ponemos self . Ser\u00eda equivalente al puntero this en C++. class Persona : #Clase persona def __init__ ( self , nombre , apellidos , altura , edad ): #Constructor self . nombre_ = nombre self . apellidos_ = apellidos self . altura_ = altura self . edad_ = edad def getnombre ( self ): #Observador que devuelve el nombre_ de la persona return self . nombre_ def getapellidos ( self ): #Observador que devuelve los apellidos_ de la persona return self . apellidos_ def getaltura ( self ): #Observador que devuelve la altura_ de la persona return self . altura_ def getedad ( self ): #Observador que devuelve el nombre_ de la persona return self . edad_ def setnombre ( self , nombre ): #Modificador que permite cambiar el nombre_ de la persona self . nombre_ = nombre def setapellidos ( self , apellidos ): #Modificador que permite cambiar los apellidos_ de la persona self . apellidos_ = apellidos def setaltura ( self , altura ): #Modificador que permite cambiar la altura_ de la persona self . altura_ = altura def setedad ( self , edad ): #Modificador que permite cambiar la edad_ de la persona self . edad_ = edad def hablar ( self ): #Metodo de la clase return \"Estoy hablando\" def caminar ( self ): #Metodo de la clase return \"Estoy caminando\" def dormir ( self ): #Metodo de la clase return \"zZz\" class Informatico ( Persona ): # Inform\u00e1tico hereda de forma p\u00fablica de persona lenguajes_ experiencia_ def __init__ ( self , lenguajes , experiencia ): self . lenguajes_ = lenguajes self . experiencia_ = experiencia def getLenguajes ( self ): return self . lenguajes_ def aprender ( self , lenguajes ): self . lenguajes_ = lenguajes return self . lenguajes_ def programar ( self ): return \"Estoy programando\" def repararPC ( self ): return \"He reparado tu pc\"","title":"\u00bfComo creamos una clase en Python?"},{"location":"Python_Avanzado/Composiciones_de_Lista/","text":"Composiciones de Lista \u00b6 Esta es otra funcionalidad interesante de Python. Supongamos que queremos separar las letras de la palabra human y a\u00f1adirlas como elementos de una lista. Lo primero que se nos viene a la mente es usar un bucle for. Ejemplo 1: iterando a trav\u00e9s de una cadena usando un for \u00b6 h_letters = [] for letter in 'human' : h_letters . append ( letter ) print ( h_letters ) Cuando ejecutamos el programa, la salida ser\u00e1: ['h', 'u', 'm', 'a', 'n'] Sin embargo, Python tiene una forma m\u00e1s sencilla de resolver este problema mediante la composici\u00f3n de listas. La composici\u00f3n de listas es una forma elegante de definir y crear listas basadas en listas existentes. Sintaxis de la composici\u00f3n de lista ( list comprehension ) \u00b6 [ expresion for item in list ] Veamos c\u00f3mo se puede escribir el programa anterior usando las composiciones de lista. Ejemplo 2: iterar a trav\u00e9s de una cadena usando las composiciones de lista \u00b6 h_letters = [ letter for letter in 'human' ] print ( h_letters ) Cuando ejecutamos el programa, la salida ser\u00e1: ['h', 'u', 'm', 'a', 'n'] En el ejemplo anterior, se asigna una nueva lista a la variable h_letters, y la lista contiene los elementos de la cadena iterable 'human'. Llamamos a la funci\u00f3n print() para imprimir la salida. Extra \u00b6 Podemos complicarlo todo lo que queramos y por ejemplo a\u00f1adir condicionales. Analiza el siguiente ejemplo: # Inicializamos la `lista` lista = [] # A\u00f1adimos valores a la `lista` for n in range ( 0 , 11 ): if ( n % 2 ) == 0 : #se ejecuta la condici\u00f3n en este caso que el n\u00famero sea par lista . append ( n ** 2 ) #elevamos el numero al cuadrado y lo a\u00f1adimos a la lista # imprimimos la `lista` print ( lista ) # Inicializamos la `lista` lista = [ n ** 2 for n in range ( 0 , 12 ) if ( n % 2 ) == 0 ] #Es lo mismo que antes pero en una sola linea # Imprimimos la `lista` print ( lista ) Consejo En general, cualquier bloque de la forma: lista = [] for elemento in iterable : if condicion : lista . append ( expresion ) Se puede sustituir por la composici\u00f3n de lista siguiente: lista = [ expresion for elemento in iterable if condicion ]","title":"Composiciones de Lista"},{"location":"Python_Avanzado/Composiciones_de_Lista/#composiciones-de-lista","text":"Esta es otra funcionalidad interesante de Python. Supongamos que queremos separar las letras de la palabra human y a\u00f1adirlas como elementos de una lista. Lo primero que se nos viene a la mente es usar un bucle for.","title":"Composiciones de Lista"},{"location":"Python_Avanzado/Composiciones_de_Lista/#ejemplo-1-iterando-a-traves-de-una-cadena-usando-un-for","text":"h_letters = [] for letter in 'human' : h_letters . append ( letter ) print ( h_letters ) Cuando ejecutamos el programa, la salida ser\u00e1: ['h', 'u', 'm', 'a', 'n'] Sin embargo, Python tiene una forma m\u00e1s sencilla de resolver este problema mediante la composici\u00f3n de listas. La composici\u00f3n de listas es una forma elegante de definir y crear listas basadas en listas existentes.","title":"Ejemplo 1: iterando a trav\u00e9s de una cadena usando un for"},{"location":"Python_Avanzado/Composiciones_de_Lista/#sintaxis-de-la-composicion-de-lista-list-comprehension","text":"[ expresion for item in list ] Veamos c\u00f3mo se puede escribir el programa anterior usando las composiciones de lista.","title":"Sintaxis de la composici\u00f3n de lista (list comprehension)"},{"location":"Python_Avanzado/Composiciones_de_Lista/#ejemplo-2-iterar-a-traves-de-una-cadena-usando-las-composiciones-de-lista","text":"h_letters = [ letter for letter in 'human' ] print ( h_letters ) Cuando ejecutamos el programa, la salida ser\u00e1: ['h', 'u', 'm', 'a', 'n'] En el ejemplo anterior, se asigna una nueva lista a la variable h_letters, y la lista contiene los elementos de la cadena iterable 'human'. Llamamos a la funci\u00f3n print() para imprimir la salida.","title":"Ejemplo 2: iterar a trav\u00e9s de una cadena usando las composiciones de lista"},{"location":"Python_Avanzado/Composiciones_de_Lista/#extra","text":"Podemos complicarlo todo lo que queramos y por ejemplo a\u00f1adir condicionales. Analiza el siguiente ejemplo: # Inicializamos la `lista` lista = [] # A\u00f1adimos valores a la `lista` for n in range ( 0 , 11 ): if ( n % 2 ) == 0 : #se ejecuta la condici\u00f3n en este caso que el n\u00famero sea par lista . append ( n ** 2 ) #elevamos el numero al cuadrado y lo a\u00f1adimos a la lista # imprimimos la `lista` print ( lista ) # Inicializamos la `lista` lista = [ n ** 2 for n in range ( 0 , 12 ) if ( n % 2 ) == 0 ] #Es lo mismo que antes pero en una sola linea # Imprimimos la `lista` print ( lista ) Consejo En general, cualquier bloque de la forma: lista = [] for elemento in iterable : if condicion : lista . append ( expresion ) Se puede sustituir por la composici\u00f3n de lista siguiente: lista = [ expresion for elemento in iterable if condicion ]","title":"Extra"},{"location":"Python_Avanzado/Ficheros/","text":"Ficheros \u00b6 Si queremos hacer que nuestros programas sean capaces de almacenar informaci\u00f3n y que la puedan recuperar posteriormente aunque hayamos reiniciado nuestro ordenador podemos hacer uso de los ficheros En Python los ficheros se abren con la funci\u00f3n open () . Como primer par\u00e1metro se pasa el nombre del fichero y como segundo par\u00e1metro una cadena con caracteres similares a los de fopen () de C. Estos son varios ejemplos de la sintaxis: Abrir y cerrar ficheros \u00b6 Abrir fichero para lectura : f = open ( \"fichero.txt\" , \"r\" ) Abrir fichero para lectura en binario : f = open ( \"fichero.txt\" , \"rb\" ) Abrir fichero para escribir desde cero : f = open ( \"fichero.txt\" , \"w\" ) Abrir fichero para a\u00f1adir al final : f = open ( \"fichero.txt\" , \"a\" ) Abrir fichero para lectura y escritura : f = open ( \"fichero.txt\" , \"r+\" ) Para cerrarlo, basta llamar a f . close () Leer de ficheros \u00b6 Para leer del fichero, podemos usar las funciones f . read () y f . readline () Lectura de todo el fichero de golpe : fichero = f . read () Lectura de 100 caracteres : dato = f . read ( 100 ) Lectura de una l\u00ednea completa : linea = f . readline () Escribir en ficheros \u00b6 Para escribir el fichero haremos uso de f . write () y la forma de escribir depender\u00e1 de como hayamos abierto el archivo: Para escribir el fichero desde cero, machacando su contenido si lo hubiera: f = open ( \"fichero.txt\" , \"w\" ) Para a\u00f1adir contenido al fichero sin borrar lo anterior: f = open ( \"fichero.txt\" , \"a\" ) Moverse por el fichero \u00b6 Con f . tell () podemos saber en qu\u00e9 posici\u00f3n estamos del fichero y con f . seek () podemos desplazarnos por \u00e9l, para leer o escribir en una determinada posici\u00f3n. f . seek ( n ) : Ir al byte n del fichero f . seek ( n , 0 ) : Equivalente al anterior f . seek ( n , 1 ) : Desplazarnos n bytes a partir de la posici\u00f3n actual del fichero f . seek ( n , 2 ) : Situarnos n bytes antes del final de fichero. El segundo par\u00e1metro en estos ejemplos es Ninguno o 0 : la posici\u00f3n es relativa al principio del fichero 1 : la posici\u00f3n es relativa a la posici\u00f3n actual 2 : la posici\u00f3n es relativa al final del fichero y hacia atr\u00e1s. Bucle para leer un fichero \u00b6 A modo de ejemplo, el siguiente programa python abre un fichero y lo copia en otro f = open ( \"origen.txt\" ) g = open ( \"destino.txt\" , \"w\" ) for linea in f : g . write ( linea ) g . close () f . close () Lo interesante aqu\u00ed es el bucle for linea in f : . Esta es una forma de recorrer un fichero de texto, obteniendo una l\u00ednea cada vez. El fichero se puede leer con f . readline () que nos da una l\u00ednea cada vez, incluyendo el salto de linea \\n al final. Cuando lleguemos a final de fichero nos devolver\u00e1 una linea vac\u00eda. Una l\u00ednea en blanco en medio del fichero nos ser\u00eda devuelta como un \\n , no como una l\u00ednea vac\u00eda \"\". El siguiente ejemplo hace la copia del fichero leyendo con readline () y en un bucle hasta fin de fichero. f = open ( \"origen.txt\" ) g = open ( \"destino.txt\" , \"w\" ) linea = f . readline () while linea != \"\" : g . write ( linea ) linea = f . readline () g . close () f . close () Consejo Una alternativa a la manera cl\u00e1sica de manejar ficheros como en C, es usar lo que se denomina context managers o \"gestores de contexto\": with open ( \"fichero.txt\" , \"r\" ) as f : for linea in f : print ( f ) print ( \"El fichero ya est\u00e1 cerrado\" ) N\u00f3tese que no hace falta llamar a f . close () . Una vez terminado el \u00e1mbito del with , el int\u00e9rprete se encarga de liberar todos los recursos. Esta es una manera muy recomendable de manejar la apertura y cierre de ficheros.","title":"Ficheros"},{"location":"Python_Avanzado/Ficheros/#ficheros","text":"Si queremos hacer que nuestros programas sean capaces de almacenar informaci\u00f3n y que la puedan recuperar posteriormente aunque hayamos reiniciado nuestro ordenador podemos hacer uso de los ficheros En Python los ficheros se abren con la funci\u00f3n open () . Como primer par\u00e1metro se pasa el nombre del fichero y como segundo par\u00e1metro una cadena con caracteres similares a los de fopen () de C. Estos son varios ejemplos de la sintaxis:","title":"Ficheros"},{"location":"Python_Avanzado/Ficheros/#abrir-y-cerrar-ficheros","text":"Abrir fichero para lectura : f = open ( \"fichero.txt\" , \"r\" ) Abrir fichero para lectura en binario : f = open ( \"fichero.txt\" , \"rb\" ) Abrir fichero para escribir desde cero : f = open ( \"fichero.txt\" , \"w\" ) Abrir fichero para a\u00f1adir al final : f = open ( \"fichero.txt\" , \"a\" ) Abrir fichero para lectura y escritura : f = open ( \"fichero.txt\" , \"r+\" ) Para cerrarlo, basta llamar a f . close ()","title":"Abrir y cerrar ficheros"},{"location":"Python_Avanzado/Ficheros/#leer-de-ficheros","text":"Para leer del fichero, podemos usar las funciones f . read () y f . readline () Lectura de todo el fichero de golpe : fichero = f . read () Lectura de 100 caracteres : dato = f . read ( 100 ) Lectura de una l\u00ednea completa : linea = f . readline ()","title":"Leer de ficheros"},{"location":"Python_Avanzado/Ficheros/#escribir-en-ficheros","text":"Para escribir el fichero haremos uso de f . write () y la forma de escribir depender\u00e1 de como hayamos abierto el archivo: Para escribir el fichero desde cero, machacando su contenido si lo hubiera: f = open ( \"fichero.txt\" , \"w\" ) Para a\u00f1adir contenido al fichero sin borrar lo anterior: f = open ( \"fichero.txt\" , \"a\" )","title":"Escribir en ficheros"},{"location":"Python_Avanzado/Ficheros/#moverse-por-el-fichero","text":"Con f . tell () podemos saber en qu\u00e9 posici\u00f3n estamos del fichero y con f . seek () podemos desplazarnos por \u00e9l, para leer o escribir en una determinada posici\u00f3n. f . seek ( n ) : Ir al byte n del fichero f . seek ( n , 0 ) : Equivalente al anterior f . seek ( n , 1 ) : Desplazarnos n bytes a partir de la posici\u00f3n actual del fichero f . seek ( n , 2 ) : Situarnos n bytes antes del final de fichero. El segundo par\u00e1metro en estos ejemplos es Ninguno o 0 : la posici\u00f3n es relativa al principio del fichero 1 : la posici\u00f3n es relativa a la posici\u00f3n actual 2 : la posici\u00f3n es relativa al final del fichero y hacia atr\u00e1s.","title":"Moverse por el fichero"},{"location":"Python_Avanzado/Ficheros/#bucle-para-leer-un-fichero","text":"A modo de ejemplo, el siguiente programa python abre un fichero y lo copia en otro f = open ( \"origen.txt\" ) g = open ( \"destino.txt\" , \"w\" ) for linea in f : g . write ( linea ) g . close () f . close () Lo interesante aqu\u00ed es el bucle for linea in f : . Esta es una forma de recorrer un fichero de texto, obteniendo una l\u00ednea cada vez. El fichero se puede leer con f . readline () que nos da una l\u00ednea cada vez, incluyendo el salto de linea \\n al final. Cuando lleguemos a final de fichero nos devolver\u00e1 una linea vac\u00eda. Una l\u00ednea en blanco en medio del fichero nos ser\u00eda devuelta como un \\n , no como una l\u00ednea vac\u00eda \"\". El siguiente ejemplo hace la copia del fichero leyendo con readline () y en un bucle hasta fin de fichero. f = open ( \"origen.txt\" ) g = open ( \"destino.txt\" , \"w\" ) linea = f . readline () while linea != \"\" : g . write ( linea ) linea = f . readline () g . close () f . close () Consejo Una alternativa a la manera cl\u00e1sica de manejar ficheros como en C, es usar lo que se denomina context managers o \"gestores de contexto\": with open ( \"fichero.txt\" , \"r\" ) as f : for linea in f : print ( f ) print ( \"El fichero ya est\u00e1 cerrado\" ) N\u00f3tese que no hace falta llamar a f . close () . Una vez terminado el \u00e1mbito del with , el int\u00e9rprete se encarga de liberar todos los recursos. Esta es una manera muy recomendable de manejar la apertura y cierre de ficheros.","title":"Bucle para leer un fichero"},{"location":"Python_B%C3%A1sico/bucles/","text":"Bucles \u00b6 Una vez ya hemos aprendido a manejar las estructuras condicionales ha llegado el momento de aprender a utilizar estructuras iterativas. Como en todos los lenguajes Python cuenta con distintos tipos de bucles que veremos a continuaci\u00f3n: Python \"\"\" for target_list in expression_list: pass while expression: pass \"\"\" # \"main\" print ( \"---------while---------\" ) contador = 1 while contador <= 100 : print ( f \"Estoy en el numero: { contador } \" ) contador = contador + 1 print ( \"---------do while---------\" ) #Hacemos que la condici\u00f3n se cumpla por defecto #antes de entrar al bucle obligando as\u00ed a la pimera iteraci\u00f3n condition = False while not condition : estacion = input ( 'Introduce el nombre de una estaci\u00f3n del a\u00f1o: ' ) condition = estacion . lower () in [ 'primavera' , 'verano' , 'oto\u00f1o' , 'invierno' ] if not condition : print ( f \" \\\" { estacion } \\\" no es el nombre de una estaci\u00f3n del a\u00f1o.\" ) print ( 'Vuelva a intentarlo.' ) print ( \"Muy bien.\" ) print ( \"---------for---------\" ) numero = int ( input ( \"\u00bfDe que n\u00famero quieres ver la tabla?: \" )) print ( f \"----Tabla del { numero } ----\" ) # \"range\" es un objeto iterable, m\u00e1s sobre ello m\u00e1s adelante for numero_tabla in range ( 1 , 11 ): print ( f \" { numero } x { numero_tabla } = { numero_tabla * numero } \" ) C++ /* for (size_t i = 0; i < count; i++) { code } while (condition) { code } do { code } while (condition); */","title":"Bucles"},{"location":"Python_B%C3%A1sico/bucles/#bucles","text":"Una vez ya hemos aprendido a manejar las estructuras condicionales ha llegado el momento de aprender a utilizar estructuras iterativas. Como en todos los lenguajes Python cuenta con distintos tipos de bucles que veremos a continuaci\u00f3n: Python \"\"\" for target_list in expression_list: pass while expression: pass \"\"\" # \"main\" print ( \"---------while---------\" ) contador = 1 while contador <= 100 : print ( f \"Estoy en el numero: { contador } \" ) contador = contador + 1 print ( \"---------do while---------\" ) #Hacemos que la condici\u00f3n se cumpla por defecto #antes de entrar al bucle obligando as\u00ed a la pimera iteraci\u00f3n condition = False while not condition : estacion = input ( 'Introduce el nombre de una estaci\u00f3n del a\u00f1o: ' ) condition = estacion . lower () in [ 'primavera' , 'verano' , 'oto\u00f1o' , 'invierno' ] if not condition : print ( f \" \\\" { estacion } \\\" no es el nombre de una estaci\u00f3n del a\u00f1o.\" ) print ( 'Vuelva a intentarlo.' ) print ( \"Muy bien.\" ) print ( \"---------for---------\" ) numero = int ( input ( \"\u00bfDe que n\u00famero quieres ver la tabla?: \" )) print ( f \"----Tabla del { numero } ----\" ) # \"range\" es un objeto iterable, m\u00e1s sobre ello m\u00e1s adelante for numero_tabla in range ( 1 , 11 ): print ( f \" { numero } x { numero_tabla } = { numero_tabla * numero } \" ) C++ /* for (size_t i = 0; i < count; i++) { code } while (condition) { code } do { code } while (condition); */","title":"Bucles"},{"location":"Python_B%C3%A1sico/cadenas/","text":"Cadenas \u00b6 Empezaremos trabajando con la entrada y salida por consola. Resulta imprescindible conocer el funcionamiento de las cadenas ya que la entrada que recibamos a trav\u00e9s de estas operaciones de E/S tendr\u00e1 este formato. Python # Podemos usar comillas dobles (\"\") o simples ('') # para definir cadenas mi_texto = '\"Taller\"' # Podemos usar las comillas de distinto tipo dentro # de la cadena sin que interfieran mi_texto2 = \"de \\\" Python \\\" \" # El \\ act\u00faa como \"car\u00e1cter de escape\" # Hace que se ignore el car\u00e1cter siguiente # para que no cierre comillas texto_unido = mi_texto + \" \" + mi_texto2 print ( texto_unido ) texto_unido = mi_texto + \" \\n \" + mi_texto2 #Salto de l\u00ednea print ( texto_unido ) texto_unido = mi_texto + \" \\t \" + mi_texto2 # Tabulaci\u00f3n print ( texto_unido ) texto_unido = mi_texto + \" \\r \" + mi_texto2 # Borra lo anterior print ( texto_unido ) C++ #include <cstdio> #include <cstdlib> #include <iostream> using namespace std ; int main () { string mi_texto = \" \\\" Taller \\\" \" ; // El \\ act\u00faa como \"car\u00e1cter de escape\" y // hace que se ignore el caracter siguiente // para que no cierre comillas string mi_texto2 = \"de \\\" Python \\\" \" ; string texto_unido = mi_texto + \" \" + mi_texto2 ; cout << texto_unido << \" \\n \" ; texto_unido = mi_texto + \" \\n \" + mi_texto2 ; // Salto de l\u00ednea cout << texto_unido << \" \\n \" ; texto_unido = mi_texto + \" \\t \" + mi_texto2 ; // Tabulaci\u00f3n cout << texto_unido << \" \\n \" ; texto_unido = mi_texto + \" \\r \" + mi_texto2 ; // Borra lo anterior cout << texto_unido << \" \\n \" ; return 0 ; }","title":"Cadenas"},{"location":"Python_B%C3%A1sico/cadenas/#cadenas","text":"Empezaremos trabajando con la entrada y salida por consola. Resulta imprescindible conocer el funcionamiento de las cadenas ya que la entrada que recibamos a trav\u00e9s de estas operaciones de E/S tendr\u00e1 este formato. Python # Podemos usar comillas dobles (\"\") o simples ('') # para definir cadenas mi_texto = '\"Taller\"' # Podemos usar las comillas de distinto tipo dentro # de la cadena sin que interfieran mi_texto2 = \"de \\\" Python \\\" \" # El \\ act\u00faa como \"car\u00e1cter de escape\" # Hace que se ignore el car\u00e1cter siguiente # para que no cierre comillas texto_unido = mi_texto + \" \" + mi_texto2 print ( texto_unido ) texto_unido = mi_texto + \" \\n \" + mi_texto2 #Salto de l\u00ednea print ( texto_unido ) texto_unido = mi_texto + \" \\t \" + mi_texto2 # Tabulaci\u00f3n print ( texto_unido ) texto_unido = mi_texto + \" \\r \" + mi_texto2 # Borra lo anterior print ( texto_unido ) C++ #include <cstdio> #include <cstdlib> #include <iostream> using namespace std ; int main () { string mi_texto = \" \\\" Taller \\\" \" ; // El \\ act\u00faa como \"car\u00e1cter de escape\" y // hace que se ignore el caracter siguiente // para que no cierre comillas string mi_texto2 = \"de \\\" Python \\\" \" ; string texto_unido = mi_texto + \" \" + mi_texto2 ; cout << texto_unido << \" \\n \" ; texto_unido = mi_texto + \" \\n \" + mi_texto2 ; // Salto de l\u00ednea cout << texto_unido << \" \\n \" ; texto_unido = mi_texto + \" \\t \" + mi_texto2 ; // Tabulaci\u00f3n cout << texto_unido << \" \\n \" ; texto_unido = mi_texto + \" \\r \" + mi_texto2 ; // Borra lo anterior cout << texto_unido << \" \\n \" ; return 0 ; }","title":"Cadenas"},{"location":"Python_B%C3%A1sico/comentarios/","text":"Comentarios \u00b6 Una de las cosas m\u00e1s importantes a la hora de programar son los comentarios. En Python como en otros muchos lenguajes existen distintos tipos de comentarios que usaremos en base al contexto y a nuestras necesidades. Python # Esto mostrar\u00e1 el texto hola por la consola print ( \"Hola\" ) # Estas dos instrucciones muestran codigo por pantalla print ( \"mundo\" ) # print(\"!!\") \"\"\" Esto no se mostrar\u00e1: print(\"Esto no se va a mostrar\") print(\"Porque estar\u00e1 en dentro de un comentario multilinea\") \"\"\" print ( \"Adios!!\" ) C++ #include <cstdio> #include <cstdlib> #include <iostream> using namespace std ; int main () { //Esto mostrar\u00e1 el texto hola por la consola cout << \"Hola \\n \" ; //Estas dos instrucciones muestran c\u00f3digo por pantalla cout << \"mundo \\n \" ; //cout<<\"!!\\n\"; /* Esto no se mostrar\u00e1: cout<<\"Esto no se va a mostrar\" cout<<\"Porque estar\u00e1 dentro de un comentario multilinea\" */ cout << \"Adios!! \\n \" ; return 0 ; }","title":"Comentarios"},{"location":"Python_B%C3%A1sico/comentarios/#comentarios","text":"Una de las cosas m\u00e1s importantes a la hora de programar son los comentarios. En Python como en otros muchos lenguajes existen distintos tipos de comentarios que usaremos en base al contexto y a nuestras necesidades. Python # Esto mostrar\u00e1 el texto hola por la consola print ( \"Hola\" ) # Estas dos instrucciones muestran codigo por pantalla print ( \"mundo\" ) # print(\"!!\") \"\"\" Esto no se mostrar\u00e1: print(\"Esto no se va a mostrar\") print(\"Porque estar\u00e1 en dentro de un comentario multilinea\") \"\"\" print ( \"Adios!!\" ) C++ #include <cstdio> #include <cstdlib> #include <iostream> using namespace std ; int main () { //Esto mostrar\u00e1 el texto hola por la consola cout << \"Hola \\n \" ; //Estas dos instrucciones muestran c\u00f3digo por pantalla cout << \"mundo \\n \" ; //cout<<\"!!\\n\"; /* Esto no se mostrar\u00e1: cout<<\"Esto no se va a mostrar\" cout<<\"Porque estar\u00e1 dentro de un comentario multilinea\" */ cout << \"Adios!! \\n \" ; return 0 ; }","title":"Comentarios"},{"location":"Python_B%C3%A1sico/condicionales/","text":"Condicionales \u00b6 Conforme vayamos avanzando nuestros programas ser\u00e1n cada vez m\u00e1s complicados y es posible que necesitemos hacer uso de estructuras condicionales que nos permitan direccionar ejecutar determinadas secciones de nuestro codigo si se cumplen determinadas condiciones. Para ello haremos uso de las estructuras condicionales que en Python son las siguientes: Python if expression : code elif expression : code else : code expression1 if condition else expression2 #Operador ternario C++ if ( condition ) { code } else if ( condition ) { code } else { code } condition ? expression1 : expression1 ; //Operador ternario switch ( expression ) { case constant - expression : code break ; default : break ; } Podemos observar que en ambos lenguajes tenemos las mismas estructuras aunque en C++ adem\u00e1s podemos hacer uso de la estructura Switch que en Python no est\u00e1 incluida. Pese a que se considera un antipatr\u00f3n, podr\u00eda implementarse en Python haciendo uso de los diccionarios: # \"main\" mes = int ( input ( \"Introduce un numero para obtener el mes que le corresponde:\" )) nombres_meses = { 1 : \"Enero\" , 2 : \"Febrero\" , 3 : \"Marzo\" , 4 : \"Abril\" , 5 : \"Mayo\" , 6 : \"Junio\" , 7 : \"Julio\" , 8 : \"Agosto\" , 9 : \"Septiembre\" , 10 : \"Octubre\" , 11 : \"Noviembre\" , 12 : \"Diciembre\" } print ( nombres_meses . get ( mes , \"No existe un mes equivalente al n\u00famero introducido\" )) Ojo En el ejemplo anterior, hemos usado nombres_meses . get ( mes , valor ) en lugar de nombres_meses [ mes ] . La funci\u00f3n get nos permite dar un valor por defecto , en caso de que la clave no exista en el diccionario. Por ejemplo, si el usuario introduce el valor 14 , nombres_meses [ 14 ] dar\u00e1 un error que terminar\u00e1 el programa.","title":"Condicionales"},{"location":"Python_B%C3%A1sico/condicionales/#condicionales","text":"Conforme vayamos avanzando nuestros programas ser\u00e1n cada vez m\u00e1s complicados y es posible que necesitemos hacer uso de estructuras condicionales que nos permitan direccionar ejecutar determinadas secciones de nuestro codigo si se cumplen determinadas condiciones. Para ello haremos uso de las estructuras condicionales que en Python son las siguientes: Python if expression : code elif expression : code else : code expression1 if condition else expression2 #Operador ternario C++ if ( condition ) { code } else if ( condition ) { code } else { code } condition ? expression1 : expression1 ; //Operador ternario switch ( expression ) { case constant - expression : code break ; default : break ; } Podemos observar que en ambos lenguajes tenemos las mismas estructuras aunque en C++ adem\u00e1s podemos hacer uso de la estructura Switch que en Python no est\u00e1 incluida. Pese a que se considera un antipatr\u00f3n, podr\u00eda implementarse en Python haciendo uso de los diccionarios: # \"main\" mes = int ( input ( \"Introduce un numero para obtener el mes que le corresponde:\" )) nombres_meses = { 1 : \"Enero\" , 2 : \"Febrero\" , 3 : \"Marzo\" , 4 : \"Abril\" , 5 : \"Mayo\" , 6 : \"Junio\" , 7 : \"Julio\" , 8 : \"Agosto\" , 9 : \"Septiembre\" , 10 : \"Octubre\" , 11 : \"Noviembre\" , 12 : \"Diciembre\" } print ( nombres_meses . get ( mes , \"No existe un mes equivalente al n\u00famero introducido\" )) Ojo En el ejemplo anterior, hemos usado nombres_meses . get ( mes , valor ) en lugar de nombres_meses [ mes ] . La funci\u00f3n get nos permite dar un valor por defecto , en caso de que la clave no exista en el diccionario. Por ejemplo, si el usuario introduce el valor 14 , nombres_meses [ 14 ] dar\u00e1 un error que terminar\u00e1 el programa.","title":"Condicionales"},{"location":"Python_B%C3%A1sico/entrada-salida/","text":"Entrada y Salida \u00b6 Cuando realicemos nuestros primeros programas necesitaremos hacer uso de la entrada y salida para poder interactuar con el usuario y que \u00e9ste pueda introducir informaci\u00f3n en nuestros programas. Para ello haremos uso de la entrada y salida por consola. Python #Entrada cadena = input ( \"Introduce una cadena: \" ) #Salida print ( cadena ) #Como formatear texto y variables en un print nombre = \"Marcos\" apellidos = \"Rivera Gavil\u00e1n\" correo = \"riveragavilanmarcos@gmail.com\" print ( \"Hola me llamo \" + nombre + \" \" + apellidos + \" y mi correo es \" + correo ) #El + concatena sin espacios print ( f \"Hola me llamo { nombre } { apellidos } y mi correo es { correo } \" ) # Al estar dentro de una cadena ponemos los espacios normalmente print ( \"Hola me llamo {} {} y mi correo es {} \" . format ( nombre , apellidos , correo )) # Al estar dentro de una cadena ponemos los espacios normalmente C++ #include <cstdio> #include <cstdlib> #include <iostream> using namespace std ; int main () { string cadena ; cout << \"Introduce una cadena: \\n \" ; //Entrada: cin >> cadena ; //Salida cout << cadena << \" \\n \" ; //Como formatear texto y variables en un print string nombre = \"Marcos\" ; string apellidos = \"Rivera Gavil\u00e1n\" ; string correo = \"riveragavilanmarcos@gmail.com\" ; cout << \"Hola me llamo \" << nombre << \" \" << apellidos << \" y mi correo es \" << correo << \" \\n \" ; //El << concatena sin espacios return 0 ; }","title":"Entrada y Salida"},{"location":"Python_B%C3%A1sico/entrada-salida/#entrada-y-salida","text":"Cuando realicemos nuestros primeros programas necesitaremos hacer uso de la entrada y salida para poder interactuar con el usuario y que \u00e9ste pueda introducir informaci\u00f3n en nuestros programas. Para ello haremos uso de la entrada y salida por consola. Python #Entrada cadena = input ( \"Introduce una cadena: \" ) #Salida print ( cadena ) #Como formatear texto y variables en un print nombre = \"Marcos\" apellidos = \"Rivera Gavil\u00e1n\" correo = \"riveragavilanmarcos@gmail.com\" print ( \"Hola me llamo \" + nombre + \" \" + apellidos + \" y mi correo es \" + correo ) #El + concatena sin espacios print ( f \"Hola me llamo { nombre } { apellidos } y mi correo es { correo } \" ) # Al estar dentro de una cadena ponemos los espacios normalmente print ( \"Hola me llamo {} {} y mi correo es {} \" . format ( nombre , apellidos , correo )) # Al estar dentro de una cadena ponemos los espacios normalmente C++ #include <cstdio> #include <cstdlib> #include <iostream> using namespace std ; int main () { string cadena ; cout << \"Introduce una cadena: \\n \" ; //Entrada: cin >> cadena ; //Salida cout << cadena << \" \\n \" ; //Como formatear texto y variables en un print string nombre = \"Marcos\" ; string apellidos = \"Rivera Gavil\u00e1n\" ; string correo = \"riveragavilanmarcos@gmail.com\" ; cout << \"Hola me llamo \" << nombre << \" \" << apellidos << \" y mi correo es \" << correo << \" \\n \" ; //El << concatena sin espacios return 0 ; }","title":"Entrada y Salida"},{"location":"Python_B%C3%A1sico/funciones/","text":"Funciones \u00b6 Si queremos que hacer que nuestro c\u00f3digo sea lo m\u00e1s mantenible posible a lo largo del tiempo pudiendo a\u00f1adir nuevas funcionalidades sin que ello suponga un exceso de carga de trabajo, debemos de considerar hacer uso de las funciones. Las funciones nos permiten simplificar nuestro programa, eliminando bloques de c\u00f3digo que se pueden llegar a repetir, por ejemplo: buscar la posici\u00f3n de un elemento en un vector o decir si un n\u00famero es primo. Si utilizamos funciones podremos separar estas funcionalidades en peque\u00f1os bloques de c\u00f3digo independientes a los que \u00fanicamente llamaremos cuando realmente sean necesario pas\u00e1ndoles (o no) una serie de valores de entrada para que nos devuelvan una determinada salida. Python def a ( b ): return 1 + b def b ( i , f ): return 1.3 + f def c (): return True def d (): print ( \"hola\" ) C++ #include <cstdio> #include <cstdlib> #include <iostream> using namespace std ; int a ( int b ) { return 1 + b ; } float b ( int b , float a ) { return 1.3 + a ; } bool c () { return true ; } void d () { cout << \"hola\" << \" \\n \" ; } Tal y como podemos observar, a diferencia de C++ las funciones de Python no requieren especificar el tipo de dato que devolver\u00e1 como salida ya que, como previamente hemos dicho, al ser de tipado din\u00e1mico el lenguaje se encarga de todo.","title":"Funciones"},{"location":"Python_B%C3%A1sico/funciones/#funciones","text":"Si queremos que hacer que nuestro c\u00f3digo sea lo m\u00e1s mantenible posible a lo largo del tiempo pudiendo a\u00f1adir nuevas funcionalidades sin que ello suponga un exceso de carga de trabajo, debemos de considerar hacer uso de las funciones. Las funciones nos permiten simplificar nuestro programa, eliminando bloques de c\u00f3digo que se pueden llegar a repetir, por ejemplo: buscar la posici\u00f3n de un elemento en un vector o decir si un n\u00famero es primo. Si utilizamos funciones podremos separar estas funcionalidades en peque\u00f1os bloques de c\u00f3digo independientes a los que \u00fanicamente llamaremos cuando realmente sean necesario pas\u00e1ndoles (o no) una serie de valores de entrada para que nos devuelvan una determinada salida. Python def a ( b ): return 1 + b def b ( i , f ): return 1.3 + f def c (): return True def d (): print ( \"hola\" ) C++ #include <cstdio> #include <cstdlib> #include <iostream> using namespace std ; int a ( int b ) { return 1 + b ; } float b ( int b , float a ) { return 1.3 + a ; } bool c () { return true ; } void d () { cout << \"hola\" << \" \\n \" ; } Tal y como podemos observar, a diferencia de C++ las funciones de Python no requieren especificar el tipo de dato que devolver\u00e1 como salida ya que, como previamente hemos dicho, al ser de tipado din\u00e1mico el lenguaje se encarga de todo.","title":"Funciones"},{"location":"Python_B%C3%A1sico/operadores-aritmeticos/","text":"Operadores Aritm\u00e9ticos \u00b6 Si queremos que nuestro programa realice operaciones aritm\u00e9ticas debemos de saber cu\u00e1les son y c\u00f3mo funcionan estos operadores Python # Suma 3 + 2 # = 5 # Resta 3 - 2 # = -1 # Multiplicaci\u00f3n 3 * 2 # = 6 # Exponenciaci\u00f3n (\"elevado a\") 3 ** 2 # = 9 # Divisi\u00f3n con decimales (a veces denominada \"true division\") 3 / 2 # = 1.5 # Divisi\u00f3n entera (se ignora el resto de la divisi\u00f3n) 3 // 2 # = 1 # M\u00f3dulo (\"resto de dividir entre...\") 3 % 2 # = 1 # Abreviaturas a += b # Equivalente a \"a = a + b\" a -= b # Equivalente a \"a = a - b\" a *= b # Equivalente a \"a = a * b\" a /= b # Equivalente a \"a = a / b\" a //= b # Equivalente a \"a = a // b\" a %= b # Equivalente a \"a = a % b\" # En python no tenemos los operadores ++ o -- # Para incrementar tenemos que hacer uso de los anteriores a += 1 a -= 1 C++ /* + suma - resta * multiplicaci\u00f3n / divisi\u00f3n % m\u00f3dulo = asignaci\u00f3n a += b equivale a: a = a + b a -= b equivale a: a = a - b a *= b equivale a: a = a * b a /= b equivale a: a = a / b a %= b equivale a: a = a % b Los 4 incrementan y decrementan pero a++ equivale a: devolver el dato y luego incrementarlo a-- equivale a: devolver el dato y luego decrementarlo ++a equivale a: incrementar el dato y luego devolverlo --a equivale a: decrementar el dato y luego devolverlo */ #include <cstdio> #include <cstdlib> #include <iostream> using namespace std ; int main ( int argc , char const * argv []) { int a = 3 ; cout << a ++<< \" \\n \" ; cout <<++ a << \" \\n \" ; cout << a --<< \" \\n \" ; cout <<-- a << \" \\n \" ; return 0 ; } Cuidado En C/C++, la asignaci\u00f3n ( = ) se considera un operador, cuyo valor es el valor de la variable de la izquierda del = despu\u00e9s de realizar la asignaci\u00f3n. Por tanto, la siguiente l\u00ednea es totalmente v\u00e1lida: int a , b ; a = b = 3 ; // Equivalente a: a = ( b = 3 ); // Tanto \"a\" como \"b\" tienen asignados el valor 3 Esto puede leerse como: La sentencia a = ( b = 3 ) consiste en evaluar la expresi\u00f3n a = ( b = 3 ) Evaluar la expresi\u00f3n a = ( b = 3 ) consiste en evaluar la expresi\u00f3n b = 3 y asignar su valor a a , el valor de la expresi\u00f3n es el nuevo valor de a . Evaluar la expresi\u00f3n b = 3 consiste en evaluar la expresi\u00f3n 3 y asignar su valor a b , el valor de la expresi\u00f3n es el nuevo valor de b . Aunque puede ser \u00fatil y elegante en ocasiones, en otras puede ser una mala pr\u00e1ctica. El problema m\u00e1s com\u00fan que nos podemos encontrar es una errata del siguiente tipo: int a ; // ... if ( a = 3 ) { // Errata: realmente quer\u00edamos comparar si \"a == 3\" // En su lugar, se asignar\u00e1 el valor 3 a \"a\" y se // ejecutar\u00e1 el bloque ya que 3 != 0 // ... } En Python, la asignaci\u00f3n NO es un operador , sino una sentencia a = 3 # V\u00e1lido if a = 3 : # Error de sint\u00e1xis, el programa falla ... Recientemente se a\u00f1adi\u00f3 al est\u00e1ndar el operador morsa ( := ) que funciona como la asignaci\u00f3n de C, pero generalmente s\u00f3lo es \u00fatil en situaciones muy concretas, puedes ignorarlo por ahora.","title":"Operadores Aritm\u00e9ticos"},{"location":"Python_B%C3%A1sico/operadores-aritmeticos/#operadores-aritmeticos","text":"Si queremos que nuestro programa realice operaciones aritm\u00e9ticas debemos de saber cu\u00e1les son y c\u00f3mo funcionan estos operadores Python # Suma 3 + 2 # = 5 # Resta 3 - 2 # = -1 # Multiplicaci\u00f3n 3 * 2 # = 6 # Exponenciaci\u00f3n (\"elevado a\") 3 ** 2 # = 9 # Divisi\u00f3n con decimales (a veces denominada \"true division\") 3 / 2 # = 1.5 # Divisi\u00f3n entera (se ignora el resto de la divisi\u00f3n) 3 // 2 # = 1 # M\u00f3dulo (\"resto de dividir entre...\") 3 % 2 # = 1 # Abreviaturas a += b # Equivalente a \"a = a + b\" a -= b # Equivalente a \"a = a - b\" a *= b # Equivalente a \"a = a * b\" a /= b # Equivalente a \"a = a / b\" a //= b # Equivalente a \"a = a // b\" a %= b # Equivalente a \"a = a % b\" # En python no tenemos los operadores ++ o -- # Para incrementar tenemos que hacer uso de los anteriores a += 1 a -= 1 C++ /* + suma - resta * multiplicaci\u00f3n / divisi\u00f3n % m\u00f3dulo = asignaci\u00f3n a += b equivale a: a = a + b a -= b equivale a: a = a - b a *= b equivale a: a = a * b a /= b equivale a: a = a / b a %= b equivale a: a = a % b Los 4 incrementan y decrementan pero a++ equivale a: devolver el dato y luego incrementarlo a-- equivale a: devolver el dato y luego decrementarlo ++a equivale a: incrementar el dato y luego devolverlo --a equivale a: decrementar el dato y luego devolverlo */ #include <cstdio> #include <cstdlib> #include <iostream> using namespace std ; int main ( int argc , char const * argv []) { int a = 3 ; cout << a ++<< \" \\n \" ; cout <<++ a << \" \\n \" ; cout << a --<< \" \\n \" ; cout <<-- a << \" \\n \" ; return 0 ; } Cuidado En C/C++, la asignaci\u00f3n ( = ) se considera un operador, cuyo valor es el valor de la variable de la izquierda del = despu\u00e9s de realizar la asignaci\u00f3n. Por tanto, la siguiente l\u00ednea es totalmente v\u00e1lida: int a , b ; a = b = 3 ; // Equivalente a: a = ( b = 3 ); // Tanto \"a\" como \"b\" tienen asignados el valor 3 Esto puede leerse como: La sentencia a = ( b = 3 ) consiste en evaluar la expresi\u00f3n a = ( b = 3 ) Evaluar la expresi\u00f3n a = ( b = 3 ) consiste en evaluar la expresi\u00f3n b = 3 y asignar su valor a a , el valor de la expresi\u00f3n es el nuevo valor de a . Evaluar la expresi\u00f3n b = 3 consiste en evaluar la expresi\u00f3n 3 y asignar su valor a b , el valor de la expresi\u00f3n es el nuevo valor de b . Aunque puede ser \u00fatil y elegante en ocasiones, en otras puede ser una mala pr\u00e1ctica. El problema m\u00e1s com\u00fan que nos podemos encontrar es una errata del siguiente tipo: int a ; // ... if ( a = 3 ) { // Errata: realmente quer\u00edamos comparar si \"a == 3\" // En su lugar, se asignar\u00e1 el valor 3 a \"a\" y se // ejecutar\u00e1 el bloque ya que 3 != 0 // ... } En Python, la asignaci\u00f3n NO es un operador , sino una sentencia a = 3 # V\u00e1lido if a = 3 : # Error de sint\u00e1xis, el programa falla ... Recientemente se a\u00f1adi\u00f3 al est\u00e1ndar el operador morsa ( := ) que funciona como la asignaci\u00f3n de C, pero generalmente s\u00f3lo es \u00fatil en situaciones muy concretas, puedes ignorarlo por ahora.","title":"Operadores Aritm\u00e9ticos"},{"location":"Python_B%C3%A1sico/operadores-logicos/","text":"Operadores L\u00f3gicos \u00b6 Tambi\u00e9n debemos de conocer el funcionamiento de los operadores l\u00f3gicos ya que son imprescindibles para poder implementar condiciones l\u00f3gicas que gu\u00eden el flujo de control de nuestro programa Python # \u00bfigual? 3 == 2 # = False # \u00bfmenor que? 3 < 2 # = False # \u00bfmayor que? 3 > 2 # = True # \u00bfmenor o igual que? 3 <= 3 # = True # \u00bfmayor o igual que? 3 >= 2 # = True # \u00bfdiferente? 3 != 2 # = True # Negaci\u00f3n l\u00f3gica (invertir el valor booleano) not ( 3 != 2 ) # = False # Conjunci\u00f3n l\u00f3gica / operador AND # True si y solo si ambos operandos son True ( 3 > 2 ) and ( 3 != 0 ) # = True # Disyunci\u00f3n l\u00f3gica / operador OR # True si alguno de los operandos es True ( 3 < 2 ) or ( 3 != 0 ) # = True C++ /* < \u00bfmenor que? > \u00bfmayor que? <= \u00bfmenor o igual que? >= \u00bfmayor o igual que? == \u00bfigual? != \u00bfdiferente? ! Negaci\u00f3n l\u00f3gica (invertir el valor booleano) && Conjunci\u00f3n l\u00f3gica / operador AND || Disyunci\u00f3n l\u00f3gica / operador OR */","title":"Operadores L\u00f3gicos"},{"location":"Python_B%C3%A1sico/operadores-logicos/#operadores-logicos","text":"Tambi\u00e9n debemos de conocer el funcionamiento de los operadores l\u00f3gicos ya que son imprescindibles para poder implementar condiciones l\u00f3gicas que gu\u00eden el flujo de control de nuestro programa Python # \u00bfigual? 3 == 2 # = False # \u00bfmenor que? 3 < 2 # = False # \u00bfmayor que? 3 > 2 # = True # \u00bfmenor o igual que? 3 <= 3 # = True # \u00bfmayor o igual que? 3 >= 2 # = True # \u00bfdiferente? 3 != 2 # = True # Negaci\u00f3n l\u00f3gica (invertir el valor booleano) not ( 3 != 2 ) # = False # Conjunci\u00f3n l\u00f3gica / operador AND # True si y solo si ambos operandos son True ( 3 > 2 ) and ( 3 != 0 ) # = True # Disyunci\u00f3n l\u00f3gica / operador OR # True si alguno de los operandos es True ( 3 < 2 ) or ( 3 != 0 ) # = True C++ /* < \u00bfmenor que? > \u00bfmayor que? <= \u00bfmenor o igual que? >= \u00bfmayor o igual que? == \u00bfigual? != \u00bfdiferente? ! Negaci\u00f3n l\u00f3gica (invertir el valor booleano) && Conjunci\u00f3n l\u00f3gica / operador AND || Disyunci\u00f3n l\u00f3gica / operador OR */","title":"Operadores L\u00f3gicos"},{"location":"Python_B%C3%A1sico/tipos-de-datos/","text":"Tipos de datos \u00b6 Cuando programamos, necesitamos poder almacenar informaci\u00f3n para poder utilizarla posteriormente. Para ello hacemos uso de las variables . En lenguajes de tipado est\u00e1tico, como C o C++, el contenido que una variable puede almacenar estar\u00e1 limitado por su tipo asociado. As\u00ed una variable de tipo bool podr\u00e1 almacenar true o false pero no 5 ya que \u00e9ste se corresponde con un tipo de dato int . Python en cambio es un lenguaje de tipado din\u00e1mico , por lo que no es necesario especificar el tipo de dato que almacenar\u00e1 la variable cuando la creamos ya que Python se encarga de hacerlo por nosotros. Aun as\u00ed, Python, como todos los lenguajes posee sus propios tipos de datos que son los siguientes: Python numero_entero = 1 #int print ( type ( numero_entero )) cadena = \"Hello World\" #str print ( type ( cadena )) booleano = True #bool print ( type ( booleano )) coma_flotante = 3.14 #float print ( type ( coma_flotante )) numero_complejo = 1 j #complex print ( type ( numero_complejo )) lista = [ 1 , 3.3 , \"python\" ] #list es una lista de datos print ( type ( lista )) tupla = ( 1 , 3.3 , \"python\" ) #tuple es una lista constante print ( type ( tupla )) conjunto = { 1 , 3.3 , \"python\" } #set colecci\u00f3n de datos \u00fanicos desordenada print ( type ( conjunto )) diccionario = { 1 : \"python\" , \"key\" : 3.3 , 4.4 : \"a\" } #dict colecci\u00f3n de pares clave-valor, tambi\u00e9n denominado \"tabla hash\" print ( type ( diccionario )) # C\u00f3mo recorrer una colecci\u00f3n l = [ numero_entero , cadena , booleano , coma_flotante , numero_complejo , lista , tupla , conjunto , diccionario ] print ( \"------------------------\" ) # Podemos usar un \u00edndice \"j\" for j in range ( len ( l )): elemento = l [ j ] print ( type ( elemento )) # Podemos o recorrer directamente la lista for elemento in l : print ( type ( elemento )) Cuidado En Python el siguiente c\u00f3digo es v\u00e1lido: a = 3 print ( a ) a = 'cadena' print ( a ) Si bien es v\u00e1lido, es recomendable evitar en la medida de lo posible que una misma variable (en este caso a ) haga referencia a valores de distinto tipo durante su tiempo de vida. Simplemente, \u00a1usa una nueva variable! C++ #include <cstdio> #include <cstdlib> #include <iostream> using namespace std ; //Comentar como se definen las variables int main () { int a = 0 ; char b ; bool c ; float d ; double e ; //almacenan m\u00e1s digitos que los floats wchar_t g ; //su tama\u00f1o es superior a los habituales 8 bits return 0 ; }","title":"Tipos de datos"},{"location":"Python_B%C3%A1sico/tipos-de-datos/#tipos-de-datos","text":"Cuando programamos, necesitamos poder almacenar informaci\u00f3n para poder utilizarla posteriormente. Para ello hacemos uso de las variables . En lenguajes de tipado est\u00e1tico, como C o C++, el contenido que una variable puede almacenar estar\u00e1 limitado por su tipo asociado. As\u00ed una variable de tipo bool podr\u00e1 almacenar true o false pero no 5 ya que \u00e9ste se corresponde con un tipo de dato int . Python en cambio es un lenguaje de tipado din\u00e1mico , por lo que no es necesario especificar el tipo de dato que almacenar\u00e1 la variable cuando la creamos ya que Python se encarga de hacerlo por nosotros. Aun as\u00ed, Python, como todos los lenguajes posee sus propios tipos de datos que son los siguientes: Python numero_entero = 1 #int print ( type ( numero_entero )) cadena = \"Hello World\" #str print ( type ( cadena )) booleano = True #bool print ( type ( booleano )) coma_flotante = 3.14 #float print ( type ( coma_flotante )) numero_complejo = 1 j #complex print ( type ( numero_complejo )) lista = [ 1 , 3.3 , \"python\" ] #list es una lista de datos print ( type ( lista )) tupla = ( 1 , 3.3 , \"python\" ) #tuple es una lista constante print ( type ( tupla )) conjunto = { 1 , 3.3 , \"python\" } #set colecci\u00f3n de datos \u00fanicos desordenada print ( type ( conjunto )) diccionario = { 1 : \"python\" , \"key\" : 3.3 , 4.4 : \"a\" } #dict colecci\u00f3n de pares clave-valor, tambi\u00e9n denominado \"tabla hash\" print ( type ( diccionario )) # C\u00f3mo recorrer una colecci\u00f3n l = [ numero_entero , cadena , booleano , coma_flotante , numero_complejo , lista , tupla , conjunto , diccionario ] print ( \"------------------------\" ) # Podemos usar un \u00edndice \"j\" for j in range ( len ( l )): elemento = l [ j ] print ( type ( elemento )) # Podemos o recorrer directamente la lista for elemento in l : print ( type ( elemento )) Cuidado En Python el siguiente c\u00f3digo es v\u00e1lido: a = 3 print ( a ) a = 'cadena' print ( a ) Si bien es v\u00e1lido, es recomendable evitar en la medida de lo posible que una misma variable (en este caso a ) haga referencia a valores de distinto tipo durante su tiempo de vida. Simplemente, \u00a1usa una nueva variable! C++ #include <cstdio> #include <cstdlib> #include <iostream> using namespace std ; //Comentar como se definen las variables int main () { int a = 0 ; char b ; bool c ; float d ; double e ; //almacenan m\u00e1s digitos que los floats wchar_t g ; //su tama\u00f1o es superior a los habituales 8 bits return 0 ; }","title":"Tipos de datos"},{"location":"Testing/Ejercicio/","text":"Ejercicio \u00b6 Enunciado \u00b6 Supongamos que tenemos que implementar una funci\u00f3n que calcule el factorial de un numero. Si seguimos al pie de la letra las indicaciones de TDD lo primero que tenemos que hacer es crear la funci\u00f3n vacia simplemente para poder llamarla, implementar su test y ejecutarlo comprobando que falla. Para ello debemos de crear un nuevo fichero al que llamaremos por ejemplo myfactorial.py en el que definiremos dicha funci\u00f3n y crearemos un fichero llamado test_.py donde crearemos nuestra funci\u00f3n test_myfactorial() Primeros pasos \u00b6 myfactorial.py \u00b6 def factorial ( numero ): return 0 test_.py \u00b6 import pytest import myfactorial def test_myfactorial (): assert myfactorial . factorial ( 3 ) == 6 Una vez hemos hecho esto debemos de implementar nuestra funci\u00f3n encargada de calcular el factorial myfactorial.py \u00b6 def factorial ( numero ): fact = 1 for i in range ( 1 , numero + 1 ): fact = fact * i return fact Una vez implementada debemos de abrir una terminal en ese mismo directorio y ejecutar el siguiente comando: pytest test_.py Y si todo ha ido bien obtendremos un resultado similar a este: ===================================== test session starts ===================================== platform linux -- Python 3.8.5, pytest-6.2.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/marcos/Desktop/Curso collected 1 item test_.py . [100%] ====================================== 1 passed in 0.01s ====================================== Hecho esto ahora te toca a t\u00ed, implementa unos test que comprueben que pasa si queremos calcular el factorial de 0 y otros que comprueben que pasa si queremos calcular el factorial de un numero negativo. Observa los resultados y refactoriza la funci\u00f3n si es necesario.","title":"Ejercicio"},{"location":"Testing/Ejercicio/#ejercicio","text":"","title":"Ejercicio"},{"location":"Testing/Ejercicio/#enunciado","text":"Supongamos que tenemos que implementar una funci\u00f3n que calcule el factorial de un numero. Si seguimos al pie de la letra las indicaciones de TDD lo primero que tenemos que hacer es crear la funci\u00f3n vacia simplemente para poder llamarla, implementar su test y ejecutarlo comprobando que falla. Para ello debemos de crear un nuevo fichero al que llamaremos por ejemplo myfactorial.py en el que definiremos dicha funci\u00f3n y crearemos un fichero llamado test_.py donde crearemos nuestra funci\u00f3n test_myfactorial()","title":"Enunciado"},{"location":"Testing/Ejercicio/#primeros-pasos","text":"","title":"Primeros pasos"},{"location":"Testing/Ejercicio/#myfactorialpy","text":"def factorial ( numero ): return 0","title":"myfactorial.py"},{"location":"Testing/Ejercicio/#test_py","text":"import pytest import myfactorial def test_myfactorial (): assert myfactorial . factorial ( 3 ) == 6 Una vez hemos hecho esto debemos de implementar nuestra funci\u00f3n encargada de calcular el factorial","title":"test_.py"},{"location":"Testing/Ejercicio/#myfactorialpy_1","text":"def factorial ( numero ): fact = 1 for i in range ( 1 , numero + 1 ): fact = fact * i return fact Una vez implementada debemos de abrir una terminal en ese mismo directorio y ejecutar el siguiente comando: pytest test_.py Y si todo ha ido bien obtendremos un resultado similar a este: ===================================== test session starts ===================================== platform linux -- Python 3.8.5, pytest-6.2.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/marcos/Desktop/Curso collected 1 item test_.py . [100%] ====================================== 1 passed in 0.01s ====================================== Hecho esto ahora te toca a t\u00ed, implementa unos test que comprueben que pasa si queremos calcular el factorial de 0 y otros que comprueben que pasa si queremos calcular el factorial de un numero negativo. Observa los resultados y refactoriza la funci\u00f3n si es necesario.","title":"myfactorial.py"},{"location":"Testing/Pytest/","text":"Pytest \u00b6 Lo primero que tenemos que hacer si queremos utilizar Pytest para testear nuestro c\u00f3digo es instalarlo para ello abriremos una nueva terminal e introduciremos el siguiente comando. Tal y como se puede ver estamos haciendo uso de pip el gestor de paquetes de Python que previamente hab\u00edamos instalado. pip install pytest Una vez hecho esto podemos comprobar la versi\u00f3n que tenemos instalada escribiendo el siguiente comando: pytest --version Y obtendr\u00edamos un resultado como este: This is pytest version 4.6.9, imported from /usr/lib/python2.7/dist-packages/pytest.pyc Una vez lo hemos instalado y hemos comprobado la versi\u00f3n que tenemos llega la hora de empezar a realizar nuestros primeros test. A la hora de escribir las pruebas es necesario que tanto los ficheros donde las vamos a escribir como las mismas funciones de prueba dentro del fichero comiencen con el prefijo test_ ya que si no cuando llamemos a pytest pasandole la ruta del directorio este no las encontrar\u00e1. Un ejemplo de llamada a Pytest ser\u00eda algo asi: pytest /home/marcos/Desktop/Curso","title":"Pytest"},{"location":"Testing/Pytest/#pytest","text":"Lo primero que tenemos que hacer si queremos utilizar Pytest para testear nuestro c\u00f3digo es instalarlo para ello abriremos una nueva terminal e introduciremos el siguiente comando. Tal y como se puede ver estamos haciendo uso de pip el gestor de paquetes de Python que previamente hab\u00edamos instalado. pip install pytest Una vez hecho esto podemos comprobar la versi\u00f3n que tenemos instalada escribiendo el siguiente comando: pytest --version Y obtendr\u00edamos un resultado como este: This is pytest version 4.6.9, imported from /usr/lib/python2.7/dist-packages/pytest.pyc Una vez lo hemos instalado y hemos comprobado la versi\u00f3n que tenemos llega la hora de empezar a realizar nuestros primeros test. A la hora de escribir las pruebas es necesario que tanto los ficheros donde las vamos a escribir como las mismas funciones de prueba dentro del fichero comiencen con el prefijo test_ ya que si no cuando llamemos a pytest pasandole la ruta del directorio este no las encontrar\u00e1. Un ejemplo de llamada a Pytest ser\u00eda algo asi: pytest /home/marcos/Desktop/Curso","title":"Pytest"},{"location":"Testing/Sintaxis/","text":"Sintaxis \u00b6 El funcionamiento de pytest es similar al de todas las librer\u00edas de testing. Esto lo podemos observar tanto en su sintaxis como en la forma de implementar los test. En este caso vamos ha hacer la comparativa entre gtest (el cual muchos de vosotros conocereis de la carrera) y pytest. Python \u00b6 assert Val1 == Val2 #\u00bfVal1 igual Val2? assert Val1 != Val2 #\u00bfVal1 diferente Val2? assert Val1 < Val2 #\u00bfVal1 menor que Val2? assert Val1 <= Val2 #\u00bfVal1 menor o igual que Val2? assert Val1 > Val2 #\u00bfVal1 mayor que Val2? assert Val1 >= Val2 #\u00bfVal1 mayor o igual que Val2? assert Val1 == TRUE #\u00bfVal1 igual TRUE? assert Val1 == FALSE #\u00bfVal1 igual FALSE? C++ \u00b6 EXPECT_EQ ( val1 , val2 ) //\u00bfVal1 igual Val2? EXPECT_NE ( val1 , val2 ) //\u00bfVal1 distinto Val2? EXPECT_LT ( val1 , val2 ) //\u00bfVal1 menor que Val2? EXPECT_LE ( val1 , val2 ) //\u00bfVal1 menor o igual que Val2? EXPECT_GT ( val1 , val2 ) //\u00bfVal1 mayor que Val2? EXPECT_GE ( val1 , val2 ) //\u00bfVal1 mayor o igual que Val2? EXPECT_TRUE ( val1 ) //\u00bfVal1 igual que TRUE? EXPECT_FALSE ( val2 ) //\u00bfVal1 igual que FALSE? Estas expresiones son las que debemos de utilizar en nuestros test cuando queramos comprobar el funcionamiento de nuestras funciones.","title":"Sintaxis"},{"location":"Testing/Sintaxis/#sintaxis","text":"El funcionamiento de pytest es similar al de todas las librer\u00edas de testing. Esto lo podemos observar tanto en su sintaxis como en la forma de implementar los test. En este caso vamos ha hacer la comparativa entre gtest (el cual muchos de vosotros conocereis de la carrera) y pytest.","title":"Sintaxis"},{"location":"Testing/Sintaxis/#python","text":"assert Val1 == Val2 #\u00bfVal1 igual Val2? assert Val1 != Val2 #\u00bfVal1 diferente Val2? assert Val1 < Val2 #\u00bfVal1 menor que Val2? assert Val1 <= Val2 #\u00bfVal1 menor o igual que Val2? assert Val1 > Val2 #\u00bfVal1 mayor que Val2? assert Val1 >= Val2 #\u00bfVal1 mayor o igual que Val2? assert Val1 == TRUE #\u00bfVal1 igual TRUE? assert Val1 == FALSE #\u00bfVal1 igual FALSE?","title":"Python"},{"location":"Testing/Sintaxis/#c","text":"EXPECT_EQ ( val1 , val2 ) //\u00bfVal1 igual Val2? EXPECT_NE ( val1 , val2 ) //\u00bfVal1 distinto Val2? EXPECT_LT ( val1 , val2 ) //\u00bfVal1 menor que Val2? EXPECT_LE ( val1 , val2 ) //\u00bfVal1 menor o igual que Val2? EXPECT_GT ( val1 , val2 ) //\u00bfVal1 mayor que Val2? EXPECT_GE ( val1 , val2 ) //\u00bfVal1 mayor o igual que Val2? EXPECT_TRUE ( val1 ) //\u00bfVal1 igual que TRUE? EXPECT_FALSE ( val2 ) //\u00bfVal1 igual que FALSE? Estas expresiones son las que debemos de utilizar en nuestros test cuando queramos comprobar el funcionamiento de nuestras funciones.","title":"C++"},{"location":"Testing/TDD/","text":"TDD \u00b6 Test Driven Developement en Python \u00b6 El desarrollo guiado por pruebas de software, o Test-driven development (TDD) es una pr\u00e1ctica de ingenier\u00eda de software que involucra otras dos pr\u00e1cticas: Escribir las pruebas primero (Test First Development) y Refactorizaci\u00f3n (Refactoring). Para escribir las pruebas generalmente se utilizan las pruebas unitarias (unit test en ingl\u00e9s). En primer lugar, se escribe una prueba y se verifica que la nueva prueba falla. A continuaci\u00f3n, se implementa el c\u00f3digo que hace que la prueba pase satisfactoriamente y seguidamente se refactoriza el c\u00f3digo escrito. El prop\u00f3sito del desarrollo guiado por pruebas es lograr un c\u00f3digo limpio que funcione. La idea es que los requisitos sean traducidos a pruebas, de este modo, cuando las pruebas pasen se garantizar\u00e1 que el software cumple con los requisitos que se han establecido. \u00bfComo podemos implementarlo en Python? \u00b6 Si bien la biblioteca est\u00e1ndar de Python viene con un marco de prueba unitario llamado unittest, Pytest es el marco de prueba de referencia para probar el c\u00f3digo Python. Pytest hace que sea f\u00e1cil escribir, organizar y ejecutar pruebas. En comparaci\u00f3n con unittest, de la biblioteca est\u00e1ndar de Python, Pytest: Requiere menos c\u00f3digo repetitivo para que sus conjuntos de pruebas sean m\u00e1s legibles. Soportes de la llanura assertdeclaraci\u00f3n, que es mucho m\u00e1s f\u00e1cil de leer y m\u00e1s f\u00e1cil de recordar en comparaci\u00f3n con los assertSomethingm\u00e9todos - como assertEquals, assertTruey assertContains- en unittest. Se actualiza con m\u00e1s frecuencia ya que no forma parte de la biblioteca est\u00e1ndar de Python. Simplifica la configuraci\u00f3n y el desmontaje del estado de prueba con su sistema de fijaci\u00f3n. Utiliza un enfoque funcional. Adem\u00e1s, con Pytest, puede tener un estilo coherente en todos sus proyectos de Python. Digamos que tiene dos aplicaciones web: una construida con Django y la otra construida con Flask. Sin Pytest, lo m\u00e1s probable es que aproveche el marco de prueba de Django junto con una extensi\u00f3n de Flask como Flask-Testing. Por lo tanto, sus conjuntos de pruebas tendr\u00edan diferentes estilos. Con Pytest, por otro lado, ambos conjuntos de pruebas tendr\u00edan un estilo de c\u00f3digo coherente, lo que facilitar\u00eda el salto de uno a otro. Pytest tambi\u00e9n tiene un gran ecosistema de complementos mantenido por la comunidad. Algunos ejemplos: Pytest-django : proporciona un conjunto de herramientas creadas espec\u00edficamente para probar aplicaciones de Django Pytest-xdist : se usa para ejecutar pruebas en paralelo Pytest-cov : agrega soporte de cobertura de c\u00f3digo Pytest-instafail : muestra fallas y errores inmediatamente en lugar de esperar hasta el final de una ejecuci\u00f3n","title":"TDD"},{"location":"Testing/TDD/#tdd","text":"","title":"TDD"},{"location":"Testing/TDD/#test-driven-developement-en-python","text":"El desarrollo guiado por pruebas de software, o Test-driven development (TDD) es una pr\u00e1ctica de ingenier\u00eda de software que involucra otras dos pr\u00e1cticas: Escribir las pruebas primero (Test First Development) y Refactorizaci\u00f3n (Refactoring). Para escribir las pruebas generalmente se utilizan las pruebas unitarias (unit test en ingl\u00e9s). En primer lugar, se escribe una prueba y se verifica que la nueva prueba falla. A continuaci\u00f3n, se implementa el c\u00f3digo que hace que la prueba pase satisfactoriamente y seguidamente se refactoriza el c\u00f3digo escrito. El prop\u00f3sito del desarrollo guiado por pruebas es lograr un c\u00f3digo limpio que funcione. La idea es que los requisitos sean traducidos a pruebas, de este modo, cuando las pruebas pasen se garantizar\u00e1 que el software cumple con los requisitos que se han establecido.","title":"Test Driven Developement en Python"},{"location":"Testing/TDD/#como-podemos-implementarlo-en-python","text":"Si bien la biblioteca est\u00e1ndar de Python viene con un marco de prueba unitario llamado unittest, Pytest es el marco de prueba de referencia para probar el c\u00f3digo Python. Pytest hace que sea f\u00e1cil escribir, organizar y ejecutar pruebas. En comparaci\u00f3n con unittest, de la biblioteca est\u00e1ndar de Python, Pytest: Requiere menos c\u00f3digo repetitivo para que sus conjuntos de pruebas sean m\u00e1s legibles. Soportes de la llanura assertdeclaraci\u00f3n, que es mucho m\u00e1s f\u00e1cil de leer y m\u00e1s f\u00e1cil de recordar en comparaci\u00f3n con los assertSomethingm\u00e9todos - como assertEquals, assertTruey assertContains- en unittest. Se actualiza con m\u00e1s frecuencia ya que no forma parte de la biblioteca est\u00e1ndar de Python. Simplifica la configuraci\u00f3n y el desmontaje del estado de prueba con su sistema de fijaci\u00f3n. Utiliza un enfoque funcional. Adem\u00e1s, con Pytest, puede tener un estilo coherente en todos sus proyectos de Python. Digamos que tiene dos aplicaciones web: una construida con Django y la otra construida con Flask. Sin Pytest, lo m\u00e1s probable es que aproveche el marco de prueba de Django junto con una extensi\u00f3n de Flask como Flask-Testing. Por lo tanto, sus conjuntos de pruebas tendr\u00edan diferentes estilos. Con Pytest, por otro lado, ambos conjuntos de pruebas tendr\u00edan un estilo de c\u00f3digo coherente, lo que facilitar\u00eda el salto de uno a otro. Pytest tambi\u00e9n tiene un gran ecosistema de complementos mantenido por la comunidad. Algunos ejemplos: Pytest-django : proporciona un conjunto de herramientas creadas espec\u00edficamente para probar aplicaciones de Django Pytest-xdist : se usa para ejecutar pruebas en paralelo Pytest-cov : agrega soporte de cobertura de c\u00f3digo Pytest-instafail : muestra fallas y errores inmediatamente en lugar de esperar hasta el final de una ejecuci\u00f3n","title":"\u00bfComo podemos implementarlo en Python?"}]}